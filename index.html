<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- Fixed viewport so the entire game fits an iPhone screen without scrolling -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Castle Vault ‚Äì Vault Street</title>
  <!-- Google Fonts for headers and retro elements -->
  <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&family=Press+Start+2P&display=swap" rel="stylesheet" />
  <!-- Firebase libraries -->
  <script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-database-compat.js"></script>
  <style>
    /* Overall Mobile & Castle Vault Theme */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;  /* Prevent scrolling */
    }
    body {
      background: url('stone-wall.jpg') repeat, linear-gradient(135deg, #444, #222);
      background-size: cover;
      font-family: 'Press Start 2P', 'MedievalSharp', sans-serif;
      color: #fdf6e3;
      display: flex;
      flex-direction: column;
    }
    header {
      text-align: center;
      background: #333;
      padding: 10px;
      border-bottom: 4px solid #d4af37;
      font-size: 1.2em;
      letter-spacing: 1px;
    }
    /* Main game screen fills remaining viewport */
    #gameScreen {
      flex: 1;
      position: relative;
      overflow: hidden;
    }
    /* Module screens (only one is visible) */
    .module {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      background: rgba(60,60,60,0.95);
      padding: 10px;
      box-sizing: border-box;
    }
    .module:not(.activeModule) {
      display: none;
    }
    /* Bottom Navigation Bar */
    #navBar {
      height: 50px;
      background: #333;
      display: flex;
      justify-content: space-around;
      align-items: center;
      border-top: 2px solid #d4af37;
    }
    #navBar button {
      background: none;
      border: none;
      color: #fdf6e3;
      font-family: 'MedievalSharp', sans-serif;
      font-size: 12px;
      padding: 5px;
      cursor: pointer;
    }
    footer {
      text-align: center;
      background: #333;
      padding: 5px;
      font-size: 10px;
      color: #ccc;
    }
    /* Ticker Banners (using marquee for now) */
    .ticker {
      background: #555;
      padding: 3px;
      font-size: 10px;
      text-align: center;
      border: 1px solid #777;
      border-radius: 4px;
      margin-bottom: 2px;
    }
    /* Section Styling */
    .section {
      padding: 10px;
      background: rgba(60,60,60,0.9);
      border: 2px solid #777;
      border-radius: 8px;
      margin-bottom: 8px;
    }
    input, button, select {
      font-family: 'Press Start 2P', 'MedievalSharp', sans-serif;
      font-size: 10px;
      padding: 4px 6px;
      margin: 4px 0;
      border: 1px solid #777;
      border-radius: 4px;
      outline: none;
    }
    input, select {
      background: #e8e0d8;
      color: #222;
    }
    button {
      background: linear-gradient(45deg, #8b8000, #555);
      color: #fdf6e3;
      transition: background 0.3s;
      cursor: pointer;
    }
    button:hover {
      background: #7a6900;
    }
    /* Tables for Vault/Market Info */
    #vaultTable {
      width: 100%;
      border-collapse: collapse;
    }
    #vaultTable th, #vaultTable td {
      border: 1px solid #777;
      padding: 4px;
      text-align: center;
      font-size: 10px;
    }
    /* Dropdowns */
    #marketDropdown, .groupDropdown, #groupSearch, #activeListingsDropdown {
      background: #e8e0d8;
      color: #222;
      padding: 6px;
      border: 1px solid #777;
      border-radius: 4px;
      margin-top: 4px;
    }
    /* Modular Market Panel */
    #marketInterface {
      max-width: 400px;
      align-self: center;
    }
    /* Persistent Group Interface */
    #guildManagement, #associationInfo {
      background: #333;
      padding: 6px;
      border: 1px solid #777;
      border-radius: 4px;
      margin-top: 4px;
    }
    /* Decorative Elements */
    .torch {
      position: absolute;
      width: 20px;
      height: 40px;
      background: url('torch.png') no-repeat center center;
      background-size: contain;
      animation: flicker 1.5s infinite alternate;
    }
    .flag {
      width: 20px;
      height: 15px;
      background: url('flag.png') no-repeat center center;
      background-size: contain;
      display: inline-block;
      vertical-align: middle;
      margin-left: 4px;
    }
    @keyframes flicker {
      0% { opacity: 0.8; }
      50% { opacity: 1; }
      100% { opacity: 0.7; }
    }
    /* Coin Icon Styling */
    .coin-icon {
      display: inline-block;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      margin-right: 4px;
      animation: spin 2s linear infinite;
      vertical-align: middle;
    }
    .coin-copper { background: #b87333; }
    .coin-silver { background: #c0c0c0; }
    .coin-gold { background: #ffd700; }
    .coin-platinum { background: #e5e4e2; }
    .coin-diamond { background: #b9f2ff; }
    .coin-iridium { background: #6a0dad; }
    .coin-rhodium { background: #ff4500; }
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <header>
    üè∞ Castle Vault ‚Äì Vault Street
  </header>
  
  <!-- Top Ticker Banners -->
  <div class="ticker"><marquee id="coinValueTicker" scrollamount="4">Coin Values: Loading...</marquee></div>
  <div class="ticker"><marquee id="circulationTicker" scrollamount="4">Circulation: Loading...</marquee></div>
  <div class="ticker"><marquee id="investmentTicker" scrollamount="4">Investments: Loading...</marquee></div>
  <div class="ticker"><marquee id="recentPurchasesMarquee" scrollamount="4">Recent Purchases: Loading...</marquee></div>
  
  <!-- Notifications -->
  <div id="notificationsBox" class="section">
    <button onclick="app.toggleNotifications()">‚úâÔ∏è</button>
    Notifications: <span id="notificationsContent">None</span>
    <div id="notificationDropdown"></div>
  </div>
  
  <!-- Main Game Screen: Modules -->
  <div id="gameScreen">
    <!-- Vault Module -->
    <div id="VaultModule" class="module activeModule">
      <div class="section" id="userInfo">
        <p>Vault Type: <span id="vaultTypeDisplay"></span> <span id="upgradeOptions"></span></p>
        <p>Cash: $<span id="cashDisplay"></span></p>
        <p id="netWorthDisplay">Net Worth: Calculating...</p>
        <p id="investmentBoxDisplay" style="display:none;">Investment Box: $<span id="investmentBox"></span></p>
        <div id="vaultClockDisplay">Vault Clock: Loading...</div>
      </div>
      <div class="section" id="themeBannerSection">
        <h3>Customize Your Castle</h3>
        <p>Owned Themes: <span id="ownedThemes">None</span></p>
        <p>Select a Theme to Purchase:</p>
        <select id="vaultTheme">
          <option value="default">Stone Wall</option>
          <option value="red">Crimson Banner</option>
          <option value="blue">Azure Keep</option>
          <option value="green">Emerald Courtyard</option>
        </select>
        <button onclick="app.purchaseTheme()">Purchase Theme</button>
        <p>Select from Inventory to Equip:</p>
        <select id="equipThemeSelect"></select>
        <button onclick="app.equipTheme()">Equip Theme</button>
      </div>
      <div class="section" id="mintingSection">
        <h3>Mint a Coin</h3>
        <button id="mintBtn" onclick="app.mintNewCoin()" disabled>Mint New Coin</button>
        <div id="mintedCoinDisplay"></div>
        <p id="mintNotice" style="color:#ff3333; font-size:10px;">Minting disabled until market conditions are met.</p>
      </div>
      <div class="section" id="vaultSection">
        <h3>My Vault</h3>
        <div id="vaultCoins"></div>
      </div>
    </div>
    
    <!-- Market Module -->
    <div id="MarketModule" class="module" style="display:none;">
      <div class="section" id="marketInterface">
        <h3>Market</h3>
        <button onclick="app.toggleMarket()">Toggle Market</button>
        <div id="marketDropdown" style="display:none;">
          <p>List coins for sale:</p>
          <div id="userCoinsForSale"></div>
          <p>Filter Listings:</p>
          <select id="marketFilter" onchange="app.updateMarketListings()">
            <option value="All">All Rarities</option>
            <option value="Copper">Copper</option>
            <option value="Silver">Silver</option>
            <option value="Gold">Gold</option>
            <option value="Platinum">Platinum</option>
            <option value="Diamond">Diamond</option>
            <option value="Iridium">Iridium</option>
            <option value="Rhodium">Rhodium</option>
          </select>
          <!-- Active Listings Drop Box -->
          <div id="activeListingsDropdown"></div>
          <p><button onclick="app.buyGroupedMarketCoins()">Buy Selected Purse</button></p>
        </div>
      </div>
    </div>
    
    <!-- Investment Module -->
    <div id="InvestmentModule" class="module" style="display:none;">
      <div class="section" id="investmentSection">
        <h3>Invest in Another Vault</h3>
        <p>(All vaults can invest; only Holdings receive investments)</p>
        <input type="text" id="investRecipient" placeholder="Recipient Username"><br>
        <input type="number" id="investAmount" placeholder="Amount ($)" min="1"><br>
        <button onclick="app.submitInvestment()">Invest</button>
      </div>
      <div class="section" id="conversionSection">
        <h3>Convert Coins to Cash</h3>
        <!-- Removed "Convert All Coins" button per requirements -->
        <p>Selective Conversion:</p>
        <select id="convertRarity">
          <option value="Copper">Copper</option>
          <option value="Silver">Silver</option>
          <option value="Gold">Gold</option>
          <option value="Platinum">Platinum</option>
          <option value="Diamond">Diamond</option>
          <option value="Iridium">Iridium</option>
          <option value="Rhodium">Rhodium</option>
        </select>
        <input type="number" id="convertQuantity" min="1" placeholder="Quantity">
        <button onclick="app.convertSelectedCoinsToCash()">Convert Selected Coins</button>
        <p id="conversionNotice" style="color:#ffa500; font-size:10px;"></p>
      </div>
    </div>
    
    <!-- Groups Module -->
    <div id="GroupModule" class="module" style="display:none;">
      <div class="section" id="groupSection">
        <h3>Guilds & Associations</h3>
        <div id="guildControls" class="groupDropdown">
          <h4>Guild (Holdings Vaults only)</h4>
          <button onclick="app.createGuild()">Create Guild</button>
          <button onclick="app.leaveGuild()">Leave Guild</button>
          <button onclick="app.inviteToGuild()">Invite to Guild</button>
          <button onclick="app.toggleGroupSearch()">Search & Join Groups</button>
          <div id="guildManagement"></div>
        </div>
        <div id="associationControls" class="groupDropdown">
          <h4>Association (Basic Vaults)</h4>
          <button onclick="app.createAssociation()">Create Association</button>
          <button onclick="app.leaveAssociation()">Leave Association</button>
          <button onclick="app.inviteToAssociation()">Invite to Association</button>
          <button onclick="app.toggleGroupSearch()">Search & Join Groups</button>
          <div id="associationInfo"><p>Association Info: None</p></div>
        </div>
      </div>
      <div class="section" id="groupSearch" style="display:none;">
        <h4>Search Groups</h4>
        <select id="groupTypeSearch">
          <option value="guilds">Guilds</option>
          <option value="associations">Associations</option>
        </select>
        <input type="text" id="searchQuery" placeholder="Enter group name...">
        <button onclick="app.searchGroups()">Search</button>
        <div id="groupSearchResults"></div>
      </div>
    </div>
  </div>
  
  <!-- Bottom Navigation Bar -->
  <nav id="navBar">
    <button onclick="switchModule('VaultModule')">Vault</button>
    <button onclick="switchModule('MarketModule')">Market</button>
    <button onclick="switchModule('InvestmentModule')">Invest</button>
    <button onclick="switchModule('GroupModule')">Groups</button>
  </nav>
  
  <footer>
    <p>&copy; 2025 Castle Vault ‚Äì Vault Street</p>
  </footer>
  
  <!-- Audio Elements -->
  <audio id="bgMusic" loop>
    <source src="bg-music.mp3" type="audio/mpeg">
  </audio>
  <audio id="sfxMint">
    <source src="sfx-mint.mp3" type="audio/mpeg">
  </audio>
  
  <!-- Consolidated Script with Modern JS, Error Handling & New Features -->
  <script>
    // Module Switch Function for Bottom Navigation
    function switchModule(moduleId) {
      const modules = document.getElementsByClassName('module');
      for(let i = 0; i < modules.length; i++){
        modules[i].classList.remove('activeModule');
        modules[i].style.display = "none";
      }
      document.getElementById(moduleId).classList.add('activeModule');
      document.getElementById(moduleId).style.display = "block";
    }

    document.addEventListener("DOMContentLoaded", () => {
      // Firebase configuration
      const firebaseConfig = {
        apiKey: "AIzaSyDfZZUf2pY9ueCx6Q7m86dnitU_voims-8",
        authDomain: "coin-flip-4a693.firebaseapp.com",
        databaseURL: "https://coin-flip-4a693-default-rtdb.firebaseio.com",
        projectId: "coin-flip-4a693",
        storageBucket: "coin-flip-4a693",
        messagingSenderId: "572907715515",
        appId: "1:572907715515:web:68a53fc5a8e4b5157fe29e"
      };
      firebase.initializeApp(firebaseConfig);
      const auth = firebase.auth();
      const db = firebase.database();

      const app = {
        currentUsername: "",
        defaultVaultType: "Basic",
        currentCash: 1000,
        canMint: false,
        marketPrices: {},
        cycleLength: 300, // seconds
        clockStartTime: Date.now(),
        vaultCycleCounter: 0,
        
        // --- Utility Functions ---
        getRarity: () => {
          const roll = Math.random() * 100;
          if(roll < 50) return "Copper";
          else if(roll < 75) return "Silver";
          else if(roll < 87) return "Gold";
          else if(roll < 94) return "Platinum";
          else if(roll < 97) return "Diamond";
          else if(roll < 99) return "Iridium";
          else return "Rhodium";
        },
        calculateVaultScore: coins => {
          if(!coins) return 0;
          const rarityValues = { Copper: 1, Silver: 2, Gold: 3, Platinum: 4, Diamond: 5, Iridium: 6, Rhodium: 7 };
          let score = 0, owned = new Set();
          Object.values(coins).forEach(c => {
            if(c && c.rarity){
              score += rarityValues[c.rarity] || 0;
              owned.add(c.rarity);
            }
          });
          if(owned.size === 7) score += 5;
          return score;
        },
        updateUserCash: () => {
          const user = auth.currentUser;
          if(!user) return;
          db.ref("users/" + user.uid + "/cash").once("value").then(snap => {
            app.currentCash = snap.val() || 0;
            document.getElementById("cashDisplay").textContent = app.currentCash.toFixed(1);
          });
        },
        playSFX: id => {
          const audio = document.getElementById(id);
          if(!localStorage.getItem("vaultAudioMuted") === "true" && audio){
            audio.pause();
            audio.currentTime = 0;
            audio.play().catch(e => console.warn("Audio error:", e));
          }
        },

        // --- Vault Clock & Net Worth Updates ---
        updateVaultClock: () => {
          const elapsed = Math.floor((Date.now() - app.clockStartTime) / 1000);
          const remaining = app.cycleLength - (elapsed % app.cycleLength);
          const minutes = Math.floor(remaining/60), seconds = remaining % 60;
          document.getElementById("vaultClockDisplay").textContent =
            `Vault Clock: ${minutes.toString().padStart(2,"0")}:${seconds.toString().padStart(2,"0")}`;
          app.updateMarketTicker();
          app.updateCirculationTicker();
          app.updateInvestmentTicker();
          app.updateNetWorth();
          if(elapsed % app.cycleLength === 0){
            app.vaultCycleCounter++;
            app.vaultClockReset();
          }
        },
        updateNetWorth: () => {
          const user = auth.currentUser;
          if(!user) return;
          db.ref("users/" + user.uid + "/coins").once("value").then(snap => {
            const coins = snap.val() || {};
            let totalCoinValue = 0;
            Object.values(coins).forEach(coin => {
              if(coin && coin.rarity) totalCoinValue += (app.marketPrices[coin.rarity] || 1);
            });
            const netWorth = app.currentCash + totalCoinValue;
            document.getElementById("netWorthDisplay").textContent = "Net Worth: $" + netWorth.toFixed(2);
          });
        },
        vaultClockReset: () => {
          console.log("Vault Cycle Reset");
          app.processMarketListingsReturn();
          app.updateMintedStats();
          app.processInvestments();
          // Additional periodic functions can be added here.
        },
        // --- Ticker Updates ---
        updateMarketTicker: () => {
          let txt = "";
          for(const r in app.marketPrices){
            const price = app.marketPrices[r];
            let indicator = price > app.basePrices[r] ? "üî∫" : price < app.basePrices[r] ? "üîª" : "‚öñÔ∏è";
            txt += `<span style="color:white;">${r}:</span> <span style="color:${price > app.basePrices[r] ? "green" : price < app.basePrices[r] ? "red" : "yellow"};">$${price.toFixed(2)}</span> ${indicator} | `;
          }
          document.getElementById("coinValueTicker").innerHTML = "Coin Values: " + txt;
        },
        updateCirculationTicker: () => {
          app.getCirculationCounts().then(counts => {
            let txt = "";
            for(const r in counts){
              let color = counts[r] < 10 ? "green" : counts[r] > 20 ? "red" : "yellow";
              txt += `<span style="color:white;">${r}:</span> <span style="color:${color};">${counts[r]}</span> | `;
            }
            document.getElementById("circulationTicker").innerHTML = "Circulation: " + txt;
          });
        },
        updateInvestmentTicker: () => {
          let totalInvestments = 0;
          db.ref("users").once("value").then(snapshot => {
            snapshot.forEach(userSnap => {
              const uData = userSnap.val();
              if(uData.vaultType === "Holdings" && uData.investmentBox){
                Object.values(uData.investmentBox).forEach(inv => { totalInvestments += inv.amount; });
              }
            });
            document.getElementById("investmentTicker").innerHTML = "Investments: $" + totalInvestments.toFixed(2);
          });
        },
        // --- Market Pricing & Grouped Listings ---
        updateMarketPrices: () => {
          db.ref("mintRegistry").once("value").then(snap => {
            const regData = snap.val() || {};
            const mintedTotal = { Copper: 0, Silver: 0, Gold: 0, Platinum: 0, Diamond: 0, Iridium: 0, Rhodium: 0 };
            for(const key in regData){
              const coin = regData[key];
              if(coin && coin.rarity) mintedTotal[coin.rarity] = (mintedTotal[coin.rarity] || 0) + 1;
            }
            app.getCirculationCounts().then(circulation => {
              const rarityUpdates = [];
              for(const rarity in app.basePrices){
                rarityUpdates.push(new Promise(resolve => {
                  const circCount = circulation[rarity] || 0;
                  const multiplier = mintedTotal[rarity] > 0 ? (mintedTotal[rarity] / (circCount+1)) : 1;
                  let newPrice = app.basePrices[rarity] * multiplier;
                  newPrice = Math.round(newPrice * 100) / 100;
                  resolve({ rarity, price: newPrice });
                }));
              }
              Promise.all(rarityUpdates).then(results => {
                results.forEach(res => { app.marketPrices[res.rarity] = res.price; });
                app.updateMarketTicker();
              });
            });
          });
        },
        getCirculationCounts: () => {
          return new Promise(resolve => {
            const counts = { Copper: 0, Silver: 0, Gold: 0, Platinum: 0, Diamond: 0, Iridium: 0, Rhodium: 0 };
            db.ref("users").once("value").then(snapshot => {
              snapshot.forEach(userSnap => {
                const uData = userSnap.val();
                if(uData.vaultType !== "Holdings" && uData.coins){
                  Object.values(uData.coins).forEach(coin => {
                    if(coin && coin.rarity) counts[coin.rarity] += 1;
                  });
                }
              });
              db.ref("marketListings").once("value").then(snap => {
                const listings = snap.val() || {};
                for(const key in listings){
                  const lst = listings[key];
                  if(!lst.fulfilled && lst.coin && lst.coin.rarity) counts[lst.coin.rarity] += 1;
                }
                resolve(counts);
              });
            });
          });
        },
        // --- Market Listings: Group Coin Purse ---
        toggleMarket: () => {
          const dropdown = document.getElementById("marketDropdown");
          dropdown.style.display = (dropdown.style.display === "none" || dropdown.style.display === "") ? "block" : "none";
          if(dropdown.style.display === "block") app.loadUserCoinsForSale();
        },
        updateMarketListings: () => {
          const filter = document.getElementById("marketFilter").value;
          db.ref("marketListings").orderByChild("listedAt").once("value").then(snap => {
            const listings = snap.val() || {};
            const grouped = {};
            for(const key in listings){
              const lst = listings[key];
              if(lst.fulfilled) continue;
              if(filter !== "All" && lst.coin.rarity !== filter) continue;
              const groupKey = lst.sellerUid + "||" + lst.coin.rarity;
              if(!grouped[groupKey]){
                // Store sellerUsername as well for display purposes.
                grouped[groupKey] = { sellerUid: lst.sellerUid, sellerUsername: lst.sellerUsername || lst.sellerUid, rarity: lst.coin.rarity, count: 0, listingKeys: [] };
              }
              grouped[groupKey].count++;
              grouped[groupKey].listingKeys.push(key);
            }
            let options = `<option value="">-- Select a Coin Purse to Buy --</option>`;
            for(const groupKey in grouped){
              const group = grouped[groupKey];
              const livePrice = app.marketPrices[group.rarity] || app.basePrices[group.rarity];
              options += `<option value="${groupKey}">${group.rarity} Purse (Seller: ${group.sellerUsername}) ‚Äî ${group.count} coin(s) @ $${livePrice.toFixed(2)} each ($${(livePrice * group.count).toFixed(2)} total)</option>`;
            }
            document.getElementById("activeListingsDropdown").innerHTML = options;
            document.getElementById("activeListingsDropdown").style.display = "block";
          });
        },
        buyGroupedMarketCoins: () => {
          const purseKey = document.getElementById("activeListingsDropdown").value;
          if(!purseKey){ alert("Select a coin purse to buy."); return; }
          const group = purseKey.split("||");
          const sellerUid = group[0], rarity = group[1];
          db.ref("marketListings").orderByChild("sellerUid").equalTo(sellerUid).once("value").then(snap => {
            const listings = snap.val() || {};
            let groupListings = [];
            for(const key in listings){
              const lst = listings[key];
              if(!lst.fulfilled && lst.coin.rarity === rarity) groupListings.push({ key, listing: lst });
            }
            if(groupListings.length === 0){ alert("No listings available in this coin purse."); return; }
            const livePrice = app.marketPrices[rarity] || app.basePrices[rarity];
            const totalCost = livePrice * groupListings.length;
            const buyer = auth.currentUser;
            db.ref("users/" + buyer.uid).once("value").then(snapBuyer => {
              const buyerData = snapBuyer.val();
              if(buyerData.vaultType === "Basic"){
                alert("Basic Vaults cannot buy coins.");
                return;
              }
              if(buyerData.cash < totalCost){
                alert("Insufficient cash.");
                return;
              }
              const newCash = buyerData.cash - totalCost;
              db.ref("users/" + buyer.uid).update({ cash: newCash });
              groupListings.forEach(item => {
                db.ref("users/" + buyer.uid + "/coins").push(item.listing.coin);
                db.ref("marketListings/" + item.key).update({ fulfilled: true });
              });
              // IMPORTANT: Credit seller's account with sale proceeds
              db.ref("users/" + groupListings[0].listing.sellerUid + "/cash").once("value").then(snapSeller => {
                const sellerCash = snapSeller.val() || 0;
                db.ref("users/" + groupListings[0].listing.sellerUid).update({ cash: Number((sellerCash + totalCost).toFixed(1)) });
              });
              alert(`Purchased ${groupListings.length} ${rarity} coin(s) for $${totalCost.toFixed(2)}.`);
              app.updateUserCash();
              app.loadVault();
              app.updateMarketListings();
              app.recordRecentPurchase({ rarity: rarity, serial: "Grouped" }, totalCost);
            });
          });
        },
        processMarketListingsReturn: () => {
          db.ref("marketListings").once("value").then(snap => {
            const listings = snap.val() || {};
            for(const key in listings){
              const lst = listings[key];
              if(!lst.fulfilled && (Date.now() - lst.listedAt) >= app.cycleLength * 1000){
                db.ref("users/" + lst.sellerUid + "/coins").push(lst.coin);
                db.ref("marketListings/" + key).remove();
              }
            }
            app.updateMarketListings();
          });
        },
        recordRecentPurchase: (coin, price) => {
          db.ref("recentPurchases").push({ rarity: coin.rarity, serial: coin.serial, price: price, timestamp: Date.now() });
          db.ref("recentPurchases").orderByChild("timestamp").limitToLast(10).once("value").then(snap => {
            const purchases = snap.val() || {};
            let txt = "Recent Purchases: ";
            Object.values(purchases).forEach(item => {
              txt += `<span class="coin-icon coin-${item.rarity.toLowerCase()}"></span>${item.rarity} @ $${item.price.toFixed(2)} | `;
            });
            document.getElementById("recentPurchasesMarquee").innerHTML = txt;
          });
        },

        // --- Investment System ---
        submitInvestment: () => {
          const investor = auth.currentUser;
          if(!investor) return;
          const recipientName = document.getElementById("investRecipient").value.trim();
          const amount = parseFloat(document.getElementById("investAmount").value);
          if(!recipientName || isNaN(amount) || amount <= 0){ alert("Enter a valid recipient and amount."); return; }
          db.ref("users/" + investor.uid).once("value").then(snap => {
            const invData = snap.val();
            if(invData.cash < amount){ alert("Insufficient cash."); return; }
            db.ref("users").orderByChild("username").equalTo(recipientName)
              .once("value").then(snap2 => {
                if(!snap2.exists()){ alert("Recipient not found."); return; }
                let recipientUid = "", recipientData = {};
                snap2.forEach(childSnap => { recipientUid = childSnap.key; recipientData = childSnap.val(); });
                if(recipientData.vaultType !== "Holdings"){
                  alert("Investments can only be received by Holdings vaults.");
                  return;
                }
                const newCash = invData.cash - amount;
                db.ref("users/" + investor.uid).update({ cash: newCash });
                db.ref("users/" + recipientUid + "/investmentBox").push({
                  from: app.currentUsername,
                  amount: amount,
                  timestamp: Date.now(),
                  processed: false,
                  netWorthAtInvestment: app.getVaultNetWorth(recipientData)
                });
                alert("Invested $" + amount + " in " + recipientName + ".");
                app.updateUserCash();
              });
          });
        },
        getVaultNetWorth: vaultData => {
          let coinValue = 0;
          if(vaultData.coins){
            Object.values(vaultData.coins).forEach(coin => {
              if(coin && coin.rarity) coinValue += (app.marketPrices[coin.rarity] || 1);
            });
          }
          return (vaultData.cash || 0) + coinValue;
        },
        processInvestments: () => {
          db.ref("users").once("value").then(snapshot => {
            snapshot.forEach(userSnap => {
              const userData = userSnap.val();
              if(userData.vaultType !== "Holdings" || !userData.investmentBox) return;
              const currentNetWorth = app.getVaultNetWorth(userData);
              for(const invKey in userData.investmentBox){
                const inv = userData.investmentBox[invKey];
                if(inv.processed) continue;
                const percentChange = (currentNetWorth - inv.netWorthAtInvestment) / inv.netWorthAtInvestment;
                const investorReturn = inv.amount * (1 + percentChange);
                const recipientBonus = inv.amount * percentChange * 0.10;
                // Here you would update the investor's cash account accordingly.
                alert(`Investment from ${inv.from} returns $${investorReturn.toFixed(2)} (Recipient bonus: $${recipientBonus.toFixed(2)})`);
                db.ref("users/" + userSnap.key + "/investmentBox/" + invKey).remove();
              }
              app.updateInvestmentTicker();
            });
          });
        },

        // --- Conversion Functions ---
        // Remove "Convert All Coins" button in HTML; only allow selective conversion.
        convertCoinsToCash: () => {
          const user = auth.currentUser;
          if(!user) return;
          db.ref("users/" + user.uid).once("value").then(snap => {
            const data = snap.val();
            const lastConv = data.lastConversion || 0;
            const currentCycleStart = app.clockStartTime + Math.floor((Date.now()-app.clockStartTime)/(app.cycleLength*1000))*(app.cycleLength*1000);
            if(lastConv > currentCycleStart){
              document.getElementById("conversionNotice").textContent = "Conversion already done this cycle.";
              return;
            }
            db.ref("users/" + user.uid + "/coins").once("value").then(snapCoins => {
              const coins = snapCoins.val() || {};
              const coinIds = Object.keys(coins);
              let totalCoinValue = 0;
              Object.values(coins).forEach(coin => {
                if(coin && coin.rarity && app.marketPrices[coin.rarity])
                  totalCoinValue += app.marketPrices[coin.rarity];
              });
              // Only Holdings vaults are allowed to convert coins.
              if(data.vaultType !== "Holdings"){
                alert("Only Holdings Vaults can convert coins to cash.");
                return;
              }
              app.conversionProcess(user, coinIds, totalCoinValue);
            });
          });
        },
        convertSelectedCoinsToCash: () => {
          const user = auth.currentUser;
          if(!user) return;
          const rarity = document.getElementById("convertRarity").value;
          const qty = Number(document.getElementById("convertQuantity").value);
          if(!qty || qty < 1){ alert("Enter a valid quantity."); return; }
          db.ref("users/" + user.uid + "/coins").once("value").then(snap => {
            const coins = snap.val() || {};
            let selectedIds = [];
            Object.entries(coins).forEach(([id, coin]) => {
              if(coin.rarity === rarity && selectedIds.length < qty)
                selectedIds.push(id);
            });
            if(selectedIds.length < qty){
              alert(`Not enough ${rarity} coins available.`);
              return;
            }
            let convValue = qty * (app.marketPrices[rarity] || 1);
            app.conversionProcess(user, selectedIds, convValue);
          });
        },
        conversionProcess: (user, coinIdArray, convValue) => {
          coinIdArray.forEach(id => { db.ref("users/" + user.uid + "/coins/" + id).remove(); });
          const newCash = Number((app.currentCash + convValue).toFixed(1));
          db.ref("users/" + user.uid).update({ cash: newCash, lastConversion: Date.now() });
          app.currentCash = newCash;
          document.getElementById("cashDisplay").textContent = newCash.toFixed(1);
          document.getElementById("conversionNotice").textContent = "Converted $" + convValue.toFixed(1) + " from coins.";
          app.loadVault();
          app.loadUserCoinsForSale();
        },

        // --- Minting Functions ---
        updateMintAccess: () => {
          app.canMint = true;
          document.getElementById("mintBtn").disabled = !app.canMint;
          document.getElementById("mintNotice").style.display = app.canMint ? "none" : "block";
        },
        mintNewCoin: (callback) => {
          const user = auth.currentUser;
          if(!user || !app.canMint) return;
          db.ref("mintedCount").once("value").then(snap => {
            const serial = (snap.val() || 0) + 1;
            const rarity = app.getRarity();
            const now = new Date().toISOString();
            const coinData = { serial, rarity, date: now };
            db.ref("mintRegistry").child("coin_" + serial).set(coinData);
            db.ref("users/" + user.uid + "/coins").child("coin_" + serial).set(coinData);
            db.ref("mintedCount").set(serial);
            app.playSFX('sfxMint');
            const coinIcon = document.createElement("div");
            coinIcon.className = `coin-icon coin-${rarity.toLowerCase()}`;
            document.getElementById("mintedCoinDisplay").appendChild(coinIcon);
            setTimeout(() => { coinIcon.style.opacity = 0; setTimeout(() => coinIcon.remove(), 1000); }, 2000);
            if(callback) callback();
            app.updateMintedStats();
            app.loadVault();
            app.loadUserCoinsForSale();
          });
        },
        loadVault: () => {
          const user = auth.currentUser;
          if(!user) return;
          db.ref("users/" + user.uid + "/coins").once("value").then(snap => {
            const data = snap.val() || {};
            const counts = { Copper: 0, Silver: 0, Gold: 0, Platinum: 0, Diamond: 0, Iridium: 0, Rhodium: 0 };
            Object.values(data).forEach(coin => { if(coin && coin.rarity) counts[coin.rarity]++; });
            let html = `<table id="vaultTable">
                          <tr>
                            <th>Rarity</th>
                            <th>Count</th>
                            <th>Total Value</th>
                          </tr>`;
            for(const r in counts){
              const currentPrice = app.marketPrices[r] || 1;
              const totalValue = counts[r] * currentPrice;
              html += `<tr>
                         <td><span class="coin-icon coin-${r.toLowerCase()}"></span>${r}</td>
                         <td>${counts[r]}</td>
                         <td>$${totalValue.toFixed(2)}</td>
                       </tr>`;
            }
            html += "</table>";
            document.getElementById("vaultCoins").innerHTML = html;
            app.updateNetWorth();
          });
        },
        loadUserCoinsForSale: () => {
          const user = auth.currentUser;
          if(!user) return;
          db.ref("users/" + user.uid + "/coins").once("value").then(snap => {
            const data = snap.val() || {};
            const counts = { Copper: 0, Silver: 0, Gold: 0, Platinum: 0, Diamond: 0, Iridium: 0, Rhodium: 0 };
            Object.values(data).forEach(coin => { if(coin && coin.rarity) counts[coin.rarity]++; });
            let html = `<table id="vaultTable">
                          <tr>
                            <th>Rarity</th>
                            <th>Available</th>
                            <th>List Qty</th>
                            <th>Action</th>
                          </tr>`;
            for(const r in counts){
              if(counts[r] > 0){
                html += `<tr>
                          <td><span class="coin-icon coin-${r.toLowerCase()}"></span>${r}</td>
                          <td>${counts[r]}</td>
                          <td><input type="number" id="listCount_${r}" min="0" max="${counts[r]}" value="0" style="width:40px;"></td>
                          <td><button onclick="app.listCoins('${r}')">List</button></td>
                        </tr>`;
              }
            }
            html += "</table>";
            document.getElementById("userCoinsForSale").innerHTML = html || "<p>No coins available for sale.</p>";
          });
        },
        // List coins for sale and remove them from the user's vault (prevent duplication)
        listCoins: rarity => {
          const user = auth.currentUser;
          if(!user) return;
          const countToList = Number(document.getElementById("listCount_" + rarity).value);
          if(countToList < 1){ alert("Enter a positive number."); return; }
          db.ref("users/" + user.uid + "/coins").orderByChild("rarity").equalTo(rarity).once("value").then(snap => {
            const coins = snap.val() || {};
            let listed = 0;
            for(const id in coins){
              if(listed >= countToList) break;
              app.listCoinForSale(id);
              listed++;
            }
            if(listed < countToList){ alert(`Only ${listed} ${rarity} coins available.`); }
          });
        },
        listCoinForSale: coinId => {
          const user = auth.currentUser;
          if(!user) return;
          db.ref("users/" + user.uid + "/coins/" + coinId).once("value").then(snap => {
            const coinData = snap.val();
            if(!coinData) return;
            // Build listing including seller's username
            const listing = { coin: coinData, sellerUid: user.uid, sellerUsername: app.currentUsername, listedAt: Date.now(), fulfilled: false };
            db.ref("marketListings").push(listing, err => {
              if(!err){
                // Remove coin from vault to avoid duplication
                db.ref("users/" + user.uid + "/coins/" + coinId).remove();
                app.loadUserCoinsForSale();
                app.updateMarketListings();
              }
            });
          });
        },

        // --- Market Listings: Grouped "Coin Purse" ---
        updateMarketListings: () => {
          const filter = document.getElementById("marketFilter").value;
          db.ref("marketListings").orderByChild("listedAt").once("value").then(snap => {
            const listings = snap.val() || {};
            const grouped = {};
            for(const key in listings){
              const lst = listings[key];
              if(lst.fulfilled) continue;
              if(filter !== "All" && lst.coin.rarity !== filter) continue;
              const groupKey = lst.sellerUid + "||" + lst.coin.rarity;
              if(!grouped[groupKey]){
                grouped[groupKey] = { sellerUid: lst.sellerUid, sellerUsername: lst.sellerUsername || lst.sellerUid, rarity: lst.coin.rarity, count: 0, listingKeys: [] };
              }
              grouped[groupKey].count++;
              grouped[groupKey].listingKeys.push(key);
            }
            let options = `<option value="">-- Select a Coin Purse to Buy --</option>`;
            for(const groupKey in grouped){
              const group = grouped[groupKey];
              const livePrice = app.marketPrices[group.rarity] || 1;
              options += `<option value="${groupKey}">${group.rarity} Purse (Seller: ${group.sellerUsername}) ‚Äî ${group.count} coin(s) @ $${livePrice.toFixed(2)} each ($${(livePrice * group.count).toFixed(2)} total)</option>`;
            }
            document.getElementById("activeListingsDropdown").innerHTML = options;
            document.getElementById("activeListingsDropdown").style.display = "block";
          });
        },
        buyGroupedMarketCoins: () => {
          const purseKey = document.getElementById("activeListingsDropdown").value;
          if(!purseKey){ alert("Select a coin purse to buy."); return; }
          const group = purseKey.split("||");
          const sellerUid = group[0], rarity = group[1];
          db.ref("marketListings").orderByChild("sellerUid").equalTo(sellerUid).once("value").then(snap => {
            const listings = snap.val() || {};
            let groupListings = [];
            for(const key in listings){
              const lst = listings[key];
              if(!lst.fulfilled && lst.coin.rarity === rarity) groupListings.push({ key, listing: lst });
            }
            if(groupListings.length === 0){ alert("No listings available in this coin purse."); return; }
            const livePrice = app.marketPrices[rarity] || 1;
            const totalCost = livePrice * groupListings.length;
            const buyer = auth.currentUser;
            db.ref("users/" + buyer.uid).once("value").then(snapBuyer => {
              const buyerData = snapBuyer.val();
              if(buyerData.vaultType === "Basic"){
                alert("Basic Vaults cannot buy coins.");
                return;
              }
              if(buyerData.cash < totalCost){
                alert("Insufficient cash.");
                return;
              }
              const newCash = buyerData.cash - totalCost;
              db.ref("users/" + buyer.uid).update({ cash: newCash });
              groupListings.forEach(item => {
                db.ref("users/" + buyer.uid + "/coins").push(item.listing.coin);
                db.ref("marketListings/" + item.key).update({ fulfilled: true });
              });
              // **Update Seller Cash:** Credit the seller with the proceeds from the sale
              db.ref("users/" + groupListings[0].listing.sellerUid + "/cash").once("value").then(snapSeller => {
                const sellerCash = snapSeller.val() || 0;
                db.ref("users/" + groupListings[0].listing.sellerUid).update({ cash: Number((sellerCash + totalCost).toFixed(1)) });
              });
              alert(`Purchased ${groupListings.length} ${rarity} coin(s) for $${totalCost.toFixed(2)}.`);
              app.updateUserCash();
              app.loadVault();
              app.updateMarketListings();
              app.recordRecentPurchase({ rarity: rarity, serial: "Grouped" }, totalCost);
            });
          });
        },
        processMarketListingsReturn: () => {
          db.ref("marketListings").once("value").then(snap => {
            const listings = snap.val() || {};
            for(const key in listings){
              const lst = listings[key];
              if(!lst.fulfilled && (Date.now() - lst.listedAt) >= app.cycleLength * 1000){
                db.ref("users/" + lst.sellerUid + "/coins").push(lst.coin);
                db.ref("marketListings/" + key).remove();
              }
            }
            app.updateMarketListings();
          });
        },
        recordRecentPurchase: (coin, price) => {
          db.ref("recentPurchases").push({ rarity: coin.rarity, serial: coin.serial, price: price, timestamp: Date.now() });
          db.ref("recentPurchases").orderByChild("timestamp").limitToLast(10).once("value").then(snap => {
            const purchases = snap.val() || {};
            let txt = "Recent Purchases: ";
            Object.values(purchases).forEach(item => {
              txt += `<span class="coin-icon coin-${item.rarity.toLowerCase()}"></span>${item.rarity} @ $${item.price.toFixed(2)} | `;
            });
            document.getElementById("recentPurchasesMarquee").innerHTML = txt;
          });
        },

        // --- Investment System ---
        submitInvestment: () => {
          const investor = auth.currentUser;
          if(!investor) return;
          const recipientName = document.getElementById("investRecipient").value.trim();
          const amount = parseFloat(document.getElementById("investAmount").value);
          if(!recipientName || isNaN(amount) || amount <= 0){ alert("Enter a valid recipient and amount."); return; }
          db.ref("users/" + investor.uid).once("value").then(snap => {
            const invData = snap.val();
            if(invData.cash < amount){ alert("Insufficient cash."); return; }
            db.ref("users").orderByChild("username").equalTo(recipientName).once("value").then(snap2 => {
              if(!snap2.exists()){ alert("Recipient not found."); return; }
              let recipientUid = "", recipientData = {};
              snap2.forEach(childSnap => { recipientUid = childSnap.key; recipientData = childSnap.val(); });
              if(recipientData.vaultType !== "Holdings"){
                alert("Investments can only be received by Holdings vaults.");
                return;
              }
              const newCash = invData.cash - amount;
              db.ref("users/" + investor.uid).update({ cash: newCash });
              db.ref("users/" + recipientUid + "/investmentBox").push({
                from: app.currentUsername,
                amount: amount,
                timestamp: Date.now(),
                processed: false,
                netWorthAtInvestment: app.getVaultNetWorth(recipientData)
              });
              alert("Invested $" + amount + " in " + recipientName + ".");
              app.updateUserCash();
            });
          });
        },
        getVaultNetWorth: vaultData => {
          let coinValue = 0;
          if(vaultData.coins){
            Object.values(vaultData.coins).forEach(coin => {
              if(coin && coin.rarity) coinValue += (app.marketPrices[coin.rarity] || 1);
            });
          }
          return (vaultData.cash || 0) + coinValue;
        },
        processInvestments: () => {
          db.ref("users").once("value").then(snapshot => {
            snapshot.forEach(userSnap => {
              const userData = userSnap.val();
              if(userData.vaultType !== "Holdings" || !userData.investmentBox) return;
              const currentNetWorth = app.getVaultNetWorth(userData);
              for(const invKey in userData.investmentBox){
                const inv = userData.investmentBox[invKey];
                if(inv.processed) continue;
                const percentChange = (currentNetWorth - inv.netWorthAtInvestment) / inv.netWorthAtInvestment;
                const investorReturn = inv.amount * (1 + percentChange);
                const recipientBonus = inv.amount * percentChange * 0.10;
                alert(`Investment from ${inv.from} returns $${investorReturn.toFixed(2)} (Recipient bonus: $${recipientBonus.toFixed(2)})`);
                db.ref("users/" + userSnap.key + "/investmentBox/" + invKey).remove();
              }
              app.updateInvestmentTicker();
            });
          });
        },

        // --- Conversion Functions ---
        // Removed "Convert All Coins" button as per requirements.
        convertCoinsToCash: () => {
          const user = auth.currentUser;
          if(!user) return;
          db.ref("users/" + user.uid).once("value").then(snap => {
            const data = snap.val();
            const lastConv = data.lastConversion || 0;
            const currentCycleStart = app.clockStartTime + Math.floor((Date.now()-app.clockStartTime)/(app.cycleLength*1000))*(app.cycleLength*1000);
            if(lastConv > currentCycleStart){
              document.getElementById("conversionNotice").textContent = "Conversion already done this cycle.";
              return;
            }
            db.ref("users/" + user.uid + "/coins").once("value").then(snapCoins => {
              const coins = snapCoins.val() || {};
              const coinIds = Object.keys(coins);
              let totalCoinValue = 0;
              Object.values(coins).forEach(coin => {
                if(coin && coin.rarity && app.marketPrices[coin.rarity])
                  totalCoinValue += app.marketPrices[coin.rarity];
              });
              if(data.vaultType !== "Holdings"){
                alert("Only Holdings Vaults can convert coins to cash.");
                return;
              }
              app.conversionProcess(user, coinIds, totalCoinValue);
            });
          });
        },
        convertSelectedCoinsToCash: () => {
          const user = auth.currentUser;
          if(!user) return;
          const rarity = document.getElementById("convertRarity").value;
          const qty = Number(document.getElementById("convertQuantity").value);
          if(!qty || qty < 1){ alert("Enter a valid quantity."); return; }
          db.ref("users/" + user.uid + "/coins").once("value").then(snap => {
            const coins = snap.val() || {};
            let selectedIds = [];
            Object.entries(coins).forEach(([id, coin]) => {
              if(coin.rarity === rarity && selectedIds.length < qty)
                selectedIds.push(id);
            });
            if(selectedIds.length < qty){
              alert(`Not enough ${rarity} coins available.`);
              return;
            }
            let convValue = qty * (app.marketPrices[rarity] || 1);
            app.conversionProcess(user, selectedIds, convValue);
          });
        },
        conversionProcess: (user, coinIdArray, convValue) => {
          coinIdArray.forEach(id => { db.ref("users/" + user.uid + "/coins/" + id).remove(); });
          const newCash = Number((app.currentCash + convValue).toFixed(1));
          db.ref("users/" + user.uid).update({ cash: newCash, lastConversion: Date.now() });
          app.currentCash = newCash;
          document.getElementById("cashDisplay").textContent = newCash.toFixed(1);
          document.getElementById("conversionNotice").textContent = "Converted $" + convValue.toFixed(1) + " from coins.";
          app.loadVault();
          app.loadUserCoinsForSale();
        },

        // --- Minting Functions ---
        updateMintAccess: () => {
          app.canMint = true;
          document.getElementById("mintBtn").disabled = !app.canMint;
          document.getElementById("mintNotice").style.display = app.canMint ? "none" : "block";
        },
        mintNewCoin: (callback) => {
          const user = auth.currentUser;
          if(!user || !app.canMint) return;
          db.ref("mintedCount").once("value").then(snap => {
            const serial = (snap.val() || 0) + 1;
            const rarity = app.getRarity();
            const now = new Date().toISOString();
            const coinData = { serial, rarity, date: now };
            db.ref("mintRegistry").child("coin_" + serial).set(coinData);
            db.ref("users/" + user.uid + "/coins").child("coin_" + serial).set(coinData);
            db.ref("mintedCount").set(serial);
            app.playSFX('sfxMint');
            const coinIcon = document.createElement("div");
            coinIcon.className = `coin-icon coin-${rarity.toLowerCase()}`;
            document.getElementById("mintedCoinDisplay").appendChild(coinIcon);
            setTimeout(() => {
              coinIcon.style.opacity = 0;
              setTimeout(() => coinIcon.remove(), 1000);
            }, 2000);
            if(callback) callback();
            app.updateMintedStats && app.updateMintedStats();
            app.loadVault();
            app.loadUserCoinsForSale();
          });
        },
        loadVault: () => {
          const user = auth.currentUser;
          if(!user) return;
          db.ref("users/" + user.uid + "/coins").once("value").then(snap => {
            const data = snap.val() || {};
            const counts = { Copper: 0, Silver: 0, Gold: 0, Platinum: 0, Diamond: 0, Iridium: 0, Rhodium: 0 };
            Object.values(data).forEach(coin => { if(coin && coin.rarity) counts[coin.rarity]++; });
            let html = `<table id="vaultTable">
                          <tr>
                            <th>Rarity</th>
                            <th>Count</th>
                            <th>Total Value</th>
                          </tr>`;
            for(const r in counts){
              const currentPrice = app.marketPrices[r] || 1;
              const totalValue = counts[r] * currentPrice;
              html += `<tr>
                         <td><span class="coin-icon coin-${r.toLowerCase()}"></span>${r}</td>
                         <td>${counts[r]}</td>
                         <td>$${totalValue.toFixed(2)}</td>
                       </tr>`;
            }
            html += "</table>";
            document.getElementById("vaultCoins").innerHTML = html;
            app.updateNetWorth();
          });
        },
        loadUserCoinsForSale: () => {
          const user = auth.currentUser;
          if(!user) return;
          db.ref("users/" + user.uid + "/coins").once("value").then(snap => {
            const data = snap.val() || {};
            const counts = { Copper: 0, Silver: 0, Gold: 0, Platinum: 0, Diamond: 0, Iridium: 0, Rhodium: 0 };
            Object.values(data).forEach(coin => { if(coin && coin.rarity) counts[coin.rarity]++; });
            let html = `<table id="vaultTable">
                          <tr>
                            <th>Rarity</th>
                            <th>Available</th>
                            <th>List Qty</th>
                            <th>Action</th>
                          </tr>`;
            for(const r in counts){
              if(counts[r] > 0){
                html += `<tr>
                          <td><span class="coin-icon coin-${r.toLowerCase()}"></span>${r}</td>
                          <td>${counts[r]}</td>
                          <td><input type="number" id="listCount_${r}" min="0" max="${counts[r]}" value="0" style="width:40px;"></td>
                          <td><button onclick="app.listCoins('${r}')">List</button></td>
                        </tr>`;
              }
            }
            html += "</table>";
            document.getElementById("userCoinsForSale").innerHTML = html || "<p>No coins available for sale.</p>";
          });
        },

        // --- Market: Grouped "Coin Purse" Listings ---
        updateMarketListings: () => {
          const filter = document.getElementById("marketFilter").value;
          db.ref("marketListings").orderByChild("listedAt").once("value").then(snap => {
            const listings = snap.val() || {};
            const grouped = {};
            for(const key in listings){
              const lst = listings[key];
              if(lst.fulfilled) continue;
              if(filter !== "All" && lst.coin.rarity !== filter) continue;
              const groupKey = lst.sellerUid + "||" + lst.coin.rarity;
              if(!grouped[groupKey]){
                grouped[groupKey] = { sellerUid: lst.sellerUid, sellerUsername: lst.sellerUsername || lst.sellerUid, rarity: lst.coin.rarity, count: 0, listingKeys: [] };
              }
              grouped[groupKey].count++;
              grouped[groupKey].listingKeys.push(key);
            }
            let options = `<option value="">-- Select a Coin Purse to Buy --</option>`;
            for(const groupKey in grouped){
              const group = grouped[groupKey];
              const livePrice = app.marketPrices[group.rarity] || 1;
              options += `<option value="${groupKey}">${group.rarity} Purse (Seller: ${group.sellerUsername}) ‚Äî ${group.count} coin(s) @ $${livePrice.toFixed(2)} each ($${(livePrice * group.count).toFixed(2)} total)</option>`;
            }
            document.getElementById("activeListingsDropdown").innerHTML = options;
            document.getElementById("activeListingsDropdown").style.display = "block";
          });
        },
        buyGroupedMarketCoins: () => {
          const purseKey = document.getElementById("activeListingsDropdown").value;
          if(!purseKey){ alert("Select a coin purse to buy."); return; }
          const group = purseKey.split("||");
          const sellerUid = group[0], rarity = group[1];
          db.ref("marketListings").orderByChild("sellerUid").equalTo(sellerUid).once("value").then(snap => {
            const listings = snap.val() || {};
            let groupListings = [];
            for(const key in listings){
              const lst = listings[key];
              if(!lst.fulfilled && lst.coin.rarity === rarity)
                groupListings.push({ key, listing: lst });
            }
            if(groupListings.length === 0){ alert("No listings available in this coin purse."); return; }
            const livePrice = app.marketPrices[rarity] || 1;
            const totalCost = livePrice * groupListings.length;
            const buyer = auth.currentUser;
            db.ref("users/" + buyer.uid).once("value").then(snapBuyer => {
              const buyerData = snapBuyer.val();
              if(buyerData.vaultType === "Basic"){
                alert("Basic Vaults cannot buy coins.");
                return;
              }
              if(buyerData.cash < totalCost){
                alert("Insufficient cash.");
                return;
              }
              const newCash = buyerData.cash - totalCost;
              db.ref("users/" + buyer.uid).update({ cash: newCash });
              groupListings.forEach(item => {
                db.ref("users/" + buyer.uid + "/coins").push(item.listing.coin);
                db.ref("marketListings/" + item.key).update({ fulfilled: true });
              });
              // Update seller's cash with proceeds from the sale
              db.ref("users/" + groupListings[0].listing.sellerUid + "/cash").once("value").then(snapSeller => {
                const sellerCash = snapSeller.val() || 0;
                db.ref("users/" + groupListings[0].listing.sellerUid).update({ cash: Number((sellerCash + totalCost).toFixed(1)) });
              });
              alert(`Purchased ${groupListings.length} ${rarity} coin(s) for $${totalCost.toFixed(2)}.`);
              app.updateUserCash();
              app.loadVault();
              app.updateMarketListings();
              app.recordRecentPurchase({ rarity: rarity, serial: "Grouped" }, totalCost);
            });
          });
        },
        processMarketListingsReturn: () => {
          db.ref("marketListings").once("value").then(snap => {
            const listings = snap.val() || {};
            for(const key in listings){
              const lst = listings[key];
              if(!lst.fulfilled && (Date.now() - lst.listedAt) >= app.cycleLength * 1000){
                db.ref("users/" + lst.sellerUid + "/coins").push(lst.coin);
                db.ref("marketListings/" + key).remove();
              }
            }
            app.updateMarketListings();
          });
        },
        recordRecentPurchase: (coin, price) => {
          db.ref("recentPurchases").push({ rarity: coin.rarity, serial: coin.serial, price: price, timestamp: Date.now() });
          db.ref("recentPurchases").orderByChild("timestamp").limitToLast(10).once("value").then(snap => {
            const purchases = snap.val() || {};
            let txt = "Recent Purchases: ";
            Object.values(purchases).forEach(item => {
              txt += `<span class="coin-icon coin-${item.rarity.toLowerCase()}"></span>${item.rarity} @ $${item.price.toFixed(2)} | `;
            });
            document.getElementById("recentPurchasesMarquee").innerHTML = txt;
          });
        },

        // --- Investment System ---
        submitInvestment: () => {
          const investor = auth.currentUser;
          if(!investor) return;
          const recipientName = document.getElementById("investRecipient").value.trim();
          const amount = parseFloat(document.getElementById("investAmount").value);
          if(!recipientName || isNaN(amount) || amount <= 0){ alert("Enter a valid recipient and amount."); return; }
          db.ref("users/" + investor.uid).once("value").then(snap => {
            const invData = snap.val();
            if(invData.cash < amount){ alert("Insufficient cash."); return; }
            db.ref("users").orderByChild("username").equalTo(recipientName).once("value").then(snap2 => {
              if(!snap2.exists()){ alert("Recipient not found."); return; }
              let recipientUid = "", recipientData = {};
              snap2.forEach(childSnap => { recipientUid = childSnap.key; recipientData = childSnap.val(); });
              if(recipientData.vaultType !== "Holdings"){
                alert("Investments can only be received by Holdings vaults.");
                return;
              }
              const newCash = invData.cash - amount;
              db.ref("users/" + investor.uid).update({ cash: newCash });
              db.ref("users/" + recipientUid + "/investmentBox").push({
                from: app.currentUsername,
                amount: amount,
                timestamp: Date.now(),
                processed: false,
                netWorthAtInvestment: app.getVaultNetWorth(recipientData)
              });
              alert("Invested $" + amount + " in " + recipientName + ".");
              app.updateUserCash();
            });
          });
        },
        getVaultNetWorth: vaultData => {
          let coinValue = 0;
          if(vaultData.coins){
            Object.values(vaultData.coins).forEach(coin => {
              if(coin && coin.rarity) coinValue += (app.marketPrices[coin.rarity] || 1);
            });
          }
          return (vaultData.cash || 0) + coinValue;
        },
        processInvestments: () => {
          db.ref("users").once("value").then(snapshot => {
            snapshot.forEach(userSnap => {
              const userData = userSnap.val();
              if(userData.vaultType !== "Holdings" || !userData.investmentBox) return;
              const currentNetWorth = app.getVaultNetWorth(userData);
              for(const invKey in userData.investmentBox){
                const inv = userData.investmentBox[invKey];
                if(inv.processed) continue;
                const percentChange = (currentNetWorth - inv.netWorthAtInvestment) / inv.netWorthAtInvestment;
                const investorReturn = inv.amount * (1 + percentChange);
                const recipientBonus = inv.amount * percentChange * 0.10;
                alert(`Investment from ${inv.from} returns $${investorReturn.toFixed(2)} (Recipient bonus: $${recipientBonus.toFixed(2)})`);
                db.ref("users/" + userSnap.key + "/investmentBox/" + invKey).remove();
              }
              app.updateInvestmentTicker();
            });
          });
        },

        // --- Conversion Functions ---
        // Only Holdings vaults can convert coins; "Convert All Coins" button removed.
        convertCoinsToCash: () => {
          const user = auth.currentUser;
          if(!user) return;
          db.ref("users/" + user.uid).once("value").then(snap => {
            const data = snap.val();
            const lastConv = data.lastConversion || 0;
            const currentCycleStart = app.clockStartTime + Math.floor((Date.now()-app.clockStartTime)/(app.cycleLength*1000))*(app.cycleLength*1000);
            if(lastConv > currentCycleStart){
              document.getElementById("conversionNotice").textContent = "Conversion already done this cycle.";
              return;
            }
            db.ref("users/" + user.uid + "/coins").once("value").then(snapCoins => {
              const coins = snapCoins.val() || {};
              const coinIds = Object.keys(coins);
              let totalCoinValue = 0;
              Object.values(coins).forEach(coin => {
                if(coin && coin.rarity && app.marketPrices[coin.rarity])
                  totalCoinValue += app.marketPrices[coin.rarity];
              });
              if(data.vaultType !== "Holdings"){
                alert("Only Holdings Vaults can convert coins to cash.");
                return;
              }
              app.conversionProcess(user, coinIds, totalCoinValue);
            });
          });
        },
        convertSelectedCoinsToCash: () => {
          const user = auth.currentUser;
          if(!user) return;
          const rarity = document.getElementById("convertRarity").value;
          const qty = Number(document.getElementById("convertQuantity").value);
          if(!qty || qty < 1){ alert("Enter a valid quantity."); return; }
          db.ref("users/" + user.uid + "/coins").once("value").then(snap => {
            const coins = snap.val() || {};
            let selectedIds = [];
            Object.entries(coins).forEach(([id, coin]) => {
              if(coin.rarity === rarity && selectedIds.length < qty)
                selectedIds.push(id);
            });
            if(selectedIds.length < qty){
              alert(`Not enough ${rarity} coins available.`);
              return;
            }
            let convValue = qty * (app.marketPrices[rarity] || 1);
            app.conversionProcess(user, selectedIds, convValue);
          });
        },
        conversionProcess: (user, coinIdArray, convValue) => {
          coinIdArray.forEach(id => { db.ref("users/" + user.uid + "/coins/" + id).remove(); });
          const newCash = Number((app.currentCash + convValue).toFixed(1));
          db.ref("users/" + user.uid).update({ cash: newCash, lastConversion: Date.now() });
          app.currentCash = newCash;
          document.getElementById("cashDisplay").textContent = newCash.toFixed(1);
          document.getElementById("conversionNotice").textContent = "Converted $" + convValue.toFixed(1) + " from coins.";
          app.loadVault();
          app.loadUserCoinsForSale();
        },

        // --- Minting Functions ---
        updateMintAccess: () => {
          app.canMint = true;
          document.getElementById("mintBtn").disabled = !app.canMint;
          document.getElementById("mintNotice").style.display = app.canMint ? "none" : "block";
        },
        mintNewCoin: (callback) => {
          const user = auth.currentUser;
          if(!user || !app.canMint) return;
          db.ref("mintedCount").once("value").then(snap => {
            const serial = (snap.val() || 0) + 1;
            const rarity = app.getRarity();
            const now = new Date().toISOString();
            const coinData = { serial, rarity, date: now };
            db.ref("mintRegistry").child("coin_" + serial).set(coinData);
            db.ref("users/" + user.uid + "/coins").child("coin_" + serial).set(coinData);
            db.ref("mintedCount").set(serial);
            app.playSFX('sfxMint');
            const coinIcon = document.createElement("div");
            coinIcon.className = `coin-icon coin-${rarity.toLowerCase()}`;
            document.getElementById("mintedCoinDisplay").appendChild(coinIcon);
            setTimeout(() => {
              coinIcon.style.opacity = 0;
              setTimeout(() => coinIcon.remove(), 1000);
            }, 2000);
            if(callback) callback();
            app.updateMintedStats && app.updateMintedStats();
            app.loadVault();
            app.loadUserCoinsForSale();
          });
        },
        loadVault: () => {
          const user = auth.currentUser;
          if(!user) return;
          db.ref("users/" + user.uid + "/coins").once("value").then(snap => {
            const data = snap.val() || {};
            const counts = { Copper: 0, Silver: 0, Gold: 0, Platinum: 0, Diamond: 0, Iridium: 0, Rhodium: 0 };
            Object.values(data).forEach(coin => { if(coin && coin.rarity) counts[coin.rarity]++; });
            let html = `<table id="vaultTable">
                          <tr>
                            <th>Rarity</th>
                            <th>Count</th>
                            <th>Total Value</th>
                          </tr>`;
            for(const r in counts){
              const currentPrice = app.marketPrices[r] || 1;
              const totalValue = counts[r] * currentPrice;
              html += `<tr>
                         <td><span class="coin-icon coin-${r.toLowerCase()}"></span>${r}</td>
                         <td>${counts[r]}</td>
                         <td>$${totalValue.toFixed(2)}</td>
                       </tr>`;
            }
            html += "</table>";
            document.getElementById("vaultCoins").innerHTML = html;
            app.updateNetWorth();
          });
        },
        loadUserCoinsForSale: () => {
          const user = auth.currentUser;
          if(!user) return;
          db.ref("users/" + user.uid + "/coins").once("value").then(snap => {
            const data = snap.val() || {};
            const counts = { Copper: 0, Silver: 0, Gold: 0, Platinum: 0, Diamond: 0, Iridium: 0, Rhodium: 0 };
            Object.values(data).forEach(coin => { if(coin && coin.rarity) counts[coin.rarity]++; });
            let html = `<table id="vaultTable">
                          <tr>
                            <th>Rarity</th>
                            <th>Available</th>
                            <th>List Qty</th>
                            <th>Action</th>
                          </tr>`;
            for(const r in counts){
              if(counts[r] > 0){
                html += `<tr>
                          <td><span class="coin-icon coin-${r.toLowerCase()}"></span>${r}</td>
                          <td>${counts[r]}</td>
                          <td><input type="number" id="listCount_${r}" min="0" max="${counts[r]}" value="0" style="width:40px;"></td>
                          <td><button onclick="app.listCoins('${r}')">List</button></td>
                        </tr>`;
              }
            }
            html += "</table>";
            document.getElementById("userCoinsForSale").innerHTML = html || "<p>No coins available for sale.</p>";
          });
        },

        // --- Market: Grouped "Coin Purse" Listings ---
        updateMarketListings: () => {
          const filter = document.getElementById("marketFilter").value;
          db.ref("marketListings").orderByChild("listedAt").once("value").then(snap => {
            const listings = snap.val() || {};
            const grouped = {};
            for(const key in listings){
              const lst = listings[key];
              if(lst.fulfilled) continue;
              if(filter !== "All" && lst.coin.rarity !== filter) continue;
              const groupKey = lst.sellerUid + "||" + lst.coin.rarity;
              if(!grouped[groupKey]){
                grouped[groupKey] = { sellerUid: lst.sellerUid, sellerUsername: lst.sellerUsername || lst.sellerUid, rarity: lst.coin.rarity, count: 0, listingKeys: [] };
              }
              grouped[groupKey].count++;
              grouped[groupKey].listingKeys.push(key);
            }
            let options = `<option value="">-- Select a Coin Purse to Buy --</option>`;
            for(const groupKey in grouped){
              const group = grouped[groupKey];
              const livePrice = app.marketPrices[group.rarity] || 1;
              options += `<option value="${groupKey}">${group.rarity} Purse (Seller: ${group.sellerUsername}) ‚Äî ${group.count} coin(s) @ $${livePrice.toFixed(2)} each ($${(livePrice * group.count).toFixed(2)} total)</option>`;
            }
            document.getElementById("activeListingsDropdown").innerHTML = options;
            document.getElementById("activeListingsDropdown").style.display = "block";
          });
        },
        buyGroupedMarketCoins: () => {
          const purseKey = document.getElementById("activeListingsDropdown").value;
          if(!purseKey){ alert("Select a coin purse to buy."); return; }
          const group = purseKey.split("||");
          const sellerUid = group[0], rarity = group[1];
          db.ref("marketListings").orderByChild("sellerUid").equalTo(sellerUid).once("value").then(snap => {
            const listings = snap.val() || {};
            let groupListings = [];
            for(const key in listings){
              const lst = listings[key];
              if(!lst.fulfilled && lst.coin.rarity === rarity)
                groupListings.push({ key, listing: lst });
            }
            if(groupListings.length === 0){ alert("No listings available in this coin purse."); return; }
            const livePrice = app.marketPrices[rarity] || 1;
            const totalCost = livePrice * groupListings.length;
            const buyer = auth.currentUser;
            db.ref("users/" + buyer.uid).once("value").then(snapBuyer => {
              const buyerData = snapBuyer.val();
              if(buyerData.vaultType === "Basic"){
                alert("Basic Vaults cannot buy coins.");
                return;
              }
              if(buyerData.cash < totalCost){
                alert("Insufficient cash.");
                return;
              }
              const newCash = buyerData.cash - totalCost;
              db.ref("users/" + buyer.uid).update({ cash: newCash });
              groupListings.forEach(item => {
                db.ref("users/" + buyer.uid + "/coins").push(item.listing.coin);
                db.ref("marketListings/" + item.key).update({ fulfilled: true });
              });
              // Credit seller with sale proceeds
              db.ref("users/" + groupListings[0].listing.sellerUid + "/cash").once("value").then(snapSeller => {
                const sellerCash = snapSeller.val() || 0;
                db.ref("users/" + groupListings[0].listing.sellerUid).update({ cash: Number((sellerCash + totalCost).toFixed(1)) });
              });
              alert(`Purchased ${groupListings.length} ${rarity} coin(s) for $${totalCost.toFixed(2)}.`);
              app.updateUserCash();
              app.loadVault();
              app.updateMarketListings();
              app.recordRecentPurchase({ rarity: rarity, serial: "Grouped" }, totalCost);
            });
          });
        },
        processMarketListingsReturn: () => {
          db.ref("marketListings").once("value").then(snap => {
            const listings = snap.val() || {};
            for(const key in listings){
              const lst = listings[key];
              if(!lst.fulfilled && (Date.now() - lst.listedAt) >= app.cycleLength * 1000){
                db.ref("users/" + lst.sellerUid + "/coins").push(lst.coin);
                db.ref("marketListings/" + key).remove();
              }
            }
            app.updateMarketListings();
          });
        },
        recordRecentPurchase: (coin, price) => {
          db.ref("recentPurchases").push({ rarity: coin.rarity, serial: coin.serial, price: price, timestamp: Date.now() });
          db.ref("recentPurchases").orderByChild("timestamp").limitToLast(10).once("value").then(snap => {
            const purchases = snap.val() || {};
            let txt = "Recent Purchases: ";
            Object.values(purchases).forEach(item => {
              txt += `<span class="coin-icon coin-${item.rarity.toLowerCase()}"></span>${item.rarity} @ $${item.price.toFixed(2)} | `;
            });
            document.getElementById("recentPurchasesMarquee").innerHTML = txt;
          });
        },

        // --- Investment System ---
        submitInvestment: () => {
          const investor = auth.currentUser;
          if(!investor) return;
          const recipientName = document.getElementById("investRecipient").value.trim();
          const amount = parseFloat(document.getElementById("investAmount").value);
          if(!recipientName || isNaN(amount) || amount <= 0){ alert("Enter a valid recipient and amount."); return; }
          db.ref("users/" + investor.uid).once("value").then(snap => {
            const invData = snap.val();
            if(invData.cash < amount){ alert("Insufficient cash."); return; }
            db.ref("users").orderByChild("username").equalTo(recipientName).once("value").then(snap2 => {
              if(!snap2.exists()){ alert("Recipient not found."); return; }
              let recipientUid = "", recipientData = {};
              snap2.forEach(childSnap => { recipientUid = childSnap.key; recipientData = childSnap.val(); });
              if(recipientData.vaultType !== "Holdings"){
                alert("Investments can only be received by Holdings vaults.");
                return;
              }
              const newCash = invData.cash - amount;
              db.ref("users/" + investor.uid).update({ cash: newCash });
              db.ref("users/" + recipientUid + "/investmentBox").push({
                from: app.currentUsername,
                amount: amount,
                timestamp: Date.now(),
                processed: false,
                netWorthAtInvestment: app.getVaultNetWorth(recipientData)
              });
              alert("Invested $" + amount + " in " + recipientName + ".");
              app.updateUserCash();
            });
          });
        },
        getVaultNetWorth: vaultData => {
          let coinValue = 0;
          if(vaultData.coins){
            Object.values(vaultData.coins).forEach(coin => {
              if(coin && coin.rarity) coinValue += (app.marketPrices[coin.rarity] || 1);
            });
          }
          return (vaultData.cash || 0) + coinValue;
        },
        processInvestments: () => {
          db.ref("users").once("value").then(snapshot => {
            snapshot.forEach(userSnap => {
              const userData = userSnap.val();
              if(userData.vaultType !== "Holdings" || !userData.investmentBox) return;
              const currentNetWorth = app.getVaultNetWorth(userData);
              for(const invKey in userData.investmentBox){
                const inv = userData.investmentBox[invKey];
                if(inv.processed) continue;
                const percentChange = (currentNetWorth - inv.netWorthAtInvestment) / inv.netWorthAtInvestment;
                const investorReturn = inv.amount * (1 + percentChange);
                const recipientBonus = inv.amount * percentChange * 0.10;
                alert(`Investment from ${inv.from} returns $${investorReturn.toFixed(2)} (Recipient bonus: $${recipientBonus.toFixed(2)})`);
                db.ref("users/" + userSnap.key + "/investmentBox/" + invKey).remove();
              }
              app.updateInvestmentTicker();
            });
          });
        },

        // --- Conversion Functions ---
        // Only Holdings vaults can convert coins. "Convert All Coins" button has been removed.
        convertCoinsToCash: () => {
          const user = auth.currentUser;
          if(!user) return;
          db.ref("users/" + user.uid).once("value").then(snap => {
            const data = snap.val();
            const lastConv = data.lastConversion || 0;
            const currentCycleStart = app.clockStartTime + Math.floor((Date.now()-app.clockStartTime)/(app.cycleLength*1000))*(app.cycleLength*1000);
            if(lastConv > currentCycleStart){
              document.getElementById("conversionNotice").textContent = "Conversion already done this cycle.";
              return;
            }
            db.ref("users/" + user.uid + "/coins").once("value").then(snapCoins => {
              const coins = snapCoins.val() || {};
              const coinIds = Object.keys(coins);
              let totalCoinValue = 0;
              Object.values(coins).forEach(coin => {
                if(coin && coin.rarity && app.marketPrices[coin.rarity])
                  totalCoinValue += app.marketPrices[coin.rarity];
              });
              if(data.vaultType !== "Holdings"){
                alert("Only Holdings Vaults can convert coins to cash.");
                return;
              }
              app.conversionProcess(user, coinIds, totalCoinValue);
            });
          });
        },
        convertSelectedCoinsToCash: () => {
          const user = auth.currentUser;
          if(!user) return;
          const rarity = document.getElementById("convertRarity").value;
          const qty = Number(document.getElementById("convertQuantity").value);
          if(!qty || qty < 1){ alert("Enter a valid quantity."); return; }
          db.ref("users/" + user.uid + "/coins").once("value").then(snap => {
            const coins = snap.val() || {};
            let selectedIds = [];
            Object.entries(coins).forEach(([id, coin]) => {
              if(coin.rarity === rarity && selectedIds.length < qty)
                selectedIds.push(id);
            });
            if(selectedIds.length < qty){
              alert(`Not enough ${rarity} coins available.`);
              return;
            }
            let convValue = qty * (app.marketPrices[rarity] || 1);
            app.conversionProcess(user, selectedIds, convValue);
          });
        },
        conversionProcess: (user, coinIdArray, convValue) => {
          coinIdArray.forEach(id => { db.ref("users/" + user.uid + "/coins/" + id).remove(); });
          const newCash = Number((app.currentCash + convValue).toFixed(1));
          db.ref("users/" + user.uid).update({ cash: newCash, lastConversion: Date.now() });
          app.currentCash = newCash;
          document.getElementById("cashDisplay").textContent = newCash.toFixed(1);
          document.getElementById("conversionNotice").textContent = "Converted $" + convValue.toFixed(1) + " from coins.";
          app.loadVault();
          app.loadUserCoinsForSale();
        },

        // --- Minting Functions ---
        updateMintAccess: () => {
          app.canMint = true;
          document.getElementById("mintBtn").disabled = !app.canMint;
          document.getElementById("mintNotice").style.display = app.canMint ? "none" : "block";
        },
        mintNewCoin: (callback) => {
          const user = auth.currentUser;
          if(!user || !app.canMint) return;
          db.ref("mintedCount").once("value").then(snap => {
            const serial = (snap.val() || 0) + 1;
            const rarity = app.getRarity();
            const now = new Date().toISOString();
            const coinData = { serial, rarity, date: now };
            db.ref("mintRegistry").child("coin_" + serial).set(coinData);
            db.ref("users/" + user.uid + "/coins").child("coin_" + serial).set(coinData);
            db.ref("mintedCount").set(serial);
            app.playSFX('sfxMint');
            const coinIcon = document.createElement("div");
            coinIcon.className = `coin-icon coin-${rarity.toLowerCase()}`;
            document.getElementById("mintedCoinDisplay").appendChild(coinIcon);
            setTimeout(() => {
              coinIcon.style.opacity = 0;
              setTimeout(() => coinIcon.remove(), 1000);
            }, 2000);
            if(callback) callback();
            app.updateMintedStats && app.updateMintedStats();
            app.loadVault();
            app.loadUserCoinsForSale();
          });
        },
        loadVault: () => {
          const user = auth.currentUser;
          if(!user) return;
          db.ref("users/" + user.uid + "/coins").once("value").then(snap => {
            const data = snap.val() || {};
            const counts = { Copper: 0, Silver: 0, Gold: 0, Platinum: 0, Diamond: 0, Iridium: 0, Rhodium: 0 };
            Object.values(data).forEach(coin => { if(coin && coin.rarity) counts[coin.rarity]++; });
            let html = `<table id="vaultTable">
                          <tr>
                            <th>Rarity</th>
                            <th>Count</th>
                            <th>Total Value</th>
                          </tr>`;
            for(const r in counts){
              const currentPrice = app.marketPrices[r] || 1;
              const totalValue = counts[r] * currentPrice;
              html += `<tr>
                         <td><span class="coin-icon coin-${r.toLowerCase()}"></span>${r}</td>
                         <td>${counts[r]}</td>
                         <td>$${totalValue.toFixed(2)}</td>
                       </tr>`;
            }
            html += "</table>";
            document.getElementById("vaultCoins").innerHTML = html;
            app.updateNetWorth();
          });
        },
        loadUserCoinsForSale: () => {
          const user = auth.currentUser;
          if(!user) return;
          db.ref("users/" + user.uid + "/coins").once("value").then(snap => {
            const data = snap.val() || {};
            const counts = { Copper: 0, Silver: 0, Gold: 0, Platinum: 0, Diamond: 0, Iridium: 0, Rhodium: 0 };
            Object.values(data).forEach(coin => { if(coin && coin.rarity) counts[coin.rarity]++; });
            let html = `<table id="vaultTable">
                          <tr>
                            <th>Rarity</th>
                            <th>Available</th>
                            <th>List Qty</th>
                            <th>Action</th>
                          </tr>`;
            for(const r in counts){
              if(counts[r] > 0){
                html += `<tr>
                          <td><span class="coin-icon coin-${r.toLowerCase()}"></span>${r}</td>
                          <td>${counts[r]}</td>
                          <td><input type="number" id="listCount_${r}" min="0" max="${counts[r]}" value="0" style="width:40px;"></td>
                          <td><button onclick="app.listCoins('${r}')">List</button></td>
                        </tr>`;
              }
            }
            html += "</table>";
            document.getElementById("userCoinsForSale").innerHTML = html || "<p>No coins available for sale.</p>";
          });
        },

        // --- Investment Ticker & System ---
        updateInvestmentTicker: () => {
          let totalInvestments = 0;
          db.ref("users").once("value").then(snapshot => {
            snapshot.forEach(userSnap => {
              const uData = userSnap.val();
              if(uData.vaultType === "Holdings" && uData.investmentBox){
                Object.values(uData.investmentBox).forEach(inv => { totalInvestments += inv.amount; });
              }
            });
            document.getElementById("investmentTicker").innerHTML = "Investments: $" + totalInvestments.toFixed(2);
          });
        },

        // --- Authentication Functions ---
        login: () => {
          const email = document.getElementById("email").value.trim();
          const pass = document.getElementById("password").value.trim();
          const usernameInput = document.getElementById("username").value.trim();
          document.getElementById("loginDebug").innerText = "";
          console.log("Attempting login for: " + email);
          auth.signInWithEmailAndPassword(email, pass)
            .then(cred => { console.log("Logged in as:", cred.user.email); })
            .catch(error => {
              console.log("Login error:", error.message);
              auth.createUserWithEmailAndPassword(email, pass)
                .then(cred => {
                  app.currentUsername = usernameInput || email.split("@")[0];
                  console.log("Account created for:", cred.user.email);
                  db.ref("users/" + cred.user.uid).set({
                    email: cred.user.email,
                    username: app.currentUsername,
                    vaultType: app.defaultVaultType,
                    cash: app.currentCash,
                    theme: "default",
                    coins: {},
                    investmentsReceived: {},
                    investmentsSent: {},
                    lastConversion: 0,
                    guild: null,
                    association: null,
                    ownedThemes: {}
                  });
                })
                .catch(err => {
                  document.getElementById("loginDebug").innerText = err.message;
                  console.error("Creation error:", err);
                  alert(err.message);
                });
            });
        },
        logout: () => { auth.signOut(); }
      };

      // Module Switching (Bottom Nav)
      document.getElementById("navBar").addEventListener("click", (e) => {
        if(e.target.tagName === "BUTTON"){
          const moduleId = e.target.getAttribute("data-module") || e.target.textContent.trim() + "Module";
          document.querySelectorAll(".module").forEach(mod => {
            mod.classList.remove("activeModule");
            mod.style.display = "none";
          });
          const activeModule = document.getElementById(moduleId);
          activeModule.classList.add("activeModule");
          activeModule.style.display = "block";
        }
      });

      // Event Listeners for buttons
      document.getElementById("purchaseThemeBtn").addEventListener("click", app.purchaseTheme);
      document.getElementById("equipThemeBtn").addEventListener("click", app.equipTheme);
      document.getElementById("mintBtn").addEventListener("click", () => { app.mintNewCoin(); });
      document.getElementById("toggleMarketBtn").addEventListener("click", app.toggleMarket);
      document.getElementById("buyGroupedMarketCoinsBtn").addEventListener("click", app.buyGroupedMarketCoins);
      document.getElementById("submitInvestmentBtn").addEventListener("click", app.submitInvestment);
      document.getElementById("convertSelectedCoinsBtn").addEventListener("click", app.convertSelectedCoinsToCash);
      document.getElementById("searchGroupsBtn").addEventListener("click", app.searchGroups);

      // Firebase Auth Listener - Update UI on state change
      auth.onAuthStateChanged(user => {
        if(user){
          document.getElementById("auth-panel").style.display = "none";
          document.getElementById("user-panel").style.display = "block";
          db.ref("users/" + user.uid).once("value").then(snap => {
            const data = snap.val() || {};
            if(!data.vaultType){ data.vaultType = app.defaultVaultType; db.ref("users/" + user.uid).update({ vaultType: app.defaultVaultType }); }
            if(!data.cash){ data.cash = app.currentCash; db.ref("users/" + user.uid).update({ cash: app.currentCash }); }
            if(!data.theme){ data.theme = "default"; db.ref("users/" + user.uid).update({ theme: "default" }); }
            document.getElementById("vaultTypeDisplay").textContent = data.vaultType;
            app.currentCash = data.cash;
            document.getElementById("cashDisplay").textContent = Number(app.currentCash).toFixed(1);
            app.currentUsername = data.username || "";
            if(!app.currentUsername){
              app.currentUsername = user.email.split("@")[0];
              db.ref("users/" + user.uid).update({ username: app.currentUsername });
            }
            document.getElementById("displayName").textContent = app.currentUsername;
            if(user.email === "stewmin20k@gmail.com"){
              app.currentUsername = "stewmin";
              db.ref("users/" + user.uid).update({ username: "stewmin" });
              document.getElementById("adminPanel").style.display = "block";
            } else {
              document.getElementById("adminPanel").style.display = "none";
            }
            if(data.vaultType === "Holdings"){
              document.getElementById("investmentBoxDisplay").style.display = "block";
              if(data.investmentBox){
                let totalInvested = 0;
                Object.values(data.investmentBox).forEach(inv => { totalInvested += inv.amount; });
                document.getElementById("investmentBox").textContent = totalInvested.toFixed(1);
              } else {
                document.getElementById("investmentBox").textContent = "0.0";
              }
            } else {
              document.getElementById("investmentBoxDisplay").style.display = "none";
            }
            app.updateMintAccess();
            app.loadVault();
            app.loadUserCoinsForSale();
            app.updateMarketListings();
            app.displayUpgradeOptions();
            app.updateInvestmentTicker();
            app.loadOwnedThemes();
            app.updateEquipThemeSelect();
          });
        } else {
          document.getElementById("auth-panel").style.display = "block";
          document.getElementById("user-panel").style.display = "none";
        }
      });

      // Audio Setup
      let muted = localStorage.getItem("vaultAudioMuted") === "true";
      document.getElementById("bgMusic").muted = muted;
      window.toggleAudio = () => {
        muted = !muted;
        localStorage.setItem("vaultAudioMuted", muted);
        document.getElementById("bgMusic").muted = muted;
      };

      // Start intervals
      setInterval(app.updateVaultClock, 1000);
      setInterval(app.updateMarketPrices, 60000);
      setInterval(app.updateMarketListings, 30000);
      setInterval(app.updateInvestmentTicker, 30000);

      // Initial calls
      app.updateVaultClock();
      app.updateMarketPrices();

      window.app = app;
    });
  </script>
</body>
</html>
