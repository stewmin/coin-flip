<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vault Street ‚Äì Final Game v2.0</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  <!-- Firebase Libraries -->
  <script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-database-compat.js"></script>
  <style>
    /* Base Styles */
    body {
      margin: 0;
      font-family: 'Press Start 2P', cursive;
      background: #111;
      color: white;
    }
    header {
      text-align: center;
      background: #000;
      padding: 20px;
      border-bottom: 2px solid gold;
    }
    .container {
      max-width: 960px;
      margin: 20px auto;
      padding: 0 20px;
    }
    .section {
      margin-top: 30px;
      padding: 15px;
      background: #1a1a1a;
      border: 2px solid #333;
      border-radius: 10px;
    }
    button, input, select {
      font-family: 'Press Start 2P', cursive;
      font-size: 10px;
      padding: 6px 10px;
      margin: 5px 0;
      cursor: pointer;
    }
    input, select {
      background: #ddd;
      color: #000;
    }
    footer {
      text-align: center;
      background: #000;
      padding: 20px;
      font-size: 10px;
      margin-top: 40px;
      color: gray;
    }
    /* Minted Stats & Market Ticker */
    #mintedStats, #marketTicker {
      text-align: center;
      background: #222;
      padding: 5px;
      font-size: 10px;
      margin-bottom: 5px;
    }
    /* Vault Clock & Leaderboard */
    #vaultClockDisplay {
      font-size: 12px;
      color: cyan;
      text-align: center;
      margin-top: 10px;
    }
    #leaderboard {
      font-size: 10px;
      margin-top: 10px;
    }
    /* Market Listings */
    #marketListings {
      margin-top: 10px;
    }
    .listing {
      border: 1px solid #444;
      padding: 5px;
      margin-bottom: 5px;
      font-size: 10px;
    }
    /* Spinning coin icons */
    .coin-icon {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 3px;
      animation: spin 2s linear infinite;
      vertical-align: middle;
    }
    .coin-copper { background: #b87333; }
    .coin-silver { background: #c0c0c0; }
    .coin-gold { background: #ffd700; }
    .coin-platinum { background: #e5e4e2; }
    .coin-diamond { background: #b9f2ff; }
    .coin-iridium { background: #6a0dad; }
    .coin-rhodium { background: #ff4500; }
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <header>
    <h1>üèõÔ∏è Vault Street ‚Äì Final Game v2.0</h1>
  </header>
  
  <!-- Minted Stats & Market Prices -->
  <div id="mintedStats">
    <p id="totalMinted">Total Minted: Loading...</p>
    <p id="todayMinted">Minted Today: Loading...</p>
  </div>
  <div id="marketTicker">
    <p id="marketPricesText">Market Prices: Loading...</p>
  </div>
  
  <div class="container">
    <!-- Authentication Panel -->
    <div id="auth-panel" class="section">
      <h2>Login / Register</h2>
      <input type="email" id="email" placeholder="Email" /><br/>
      <input type="password" id="password" placeholder="Password" /><br/>
      <input type="text" id="username" placeholder="Choose Username" /><br/>
      <!-- Vault type selection removed; all new users start as Basic -->
      <button onclick="login()">Login / Register</button>
    </div>
    
    <!-- User Panel -->
    <div id="user-panel" class="section" style="display: none;">
      <div style="text-align: right;"><button onclick="logout()">Logout</button></div>
      <h2>Welcome, <span id="displayName"></span></h2>
      
      <!-- Admin Controls -->
      <div id="adminPanel" style="display: none; margin-bottom: 10px;">
        <button onclick="adminResetMarket()">Admin: Reset Market</button>
        <button onclick="adminClearCoinHistory()">Admin: Clear Coin History</button>
      </div>
      
      <!-- User Information & Vault Clock -->
      <div id="userInfo" class="section">
        <p>Vault Type: <span id="vaultTypeDisplay"></span></p>
        <p>Cash: $<span id="cashDisplay"></span></p>
        <div id="vaultClockDisplay">Vault Clock: Loading...</div>
      </div>
      
      <!-- Theme & Banner Customization -->
      <div id="themeBannerSection" class="section">
        <h3>Customize Your Vault</h3>
        <p>Theme (UI always shows $250)</p>
        <select id="vaultTheme">
          <option value="default">Gray Default</option>
          <option value="red">Red</option>
          <option value="blue">Blue</option>
          <option value="green">Green</option>
        </select>
        <button onclick="updateVaultTheme()">Apply Theme</button>
        <p>Banner: (Coming Soon)</p>
      </div>
      
      <!-- Minting Section -->
      <div id="mintingSection" class="section">
        <h3>Mint a Coin</h3>
        <button id="mintBtn" onclick="mintNewCoin()" disabled>Mint New Coin</button>
        <p id="mintNotice" style="color: red; font-size:10px;">Minting disabled until market conditions are met.</p>
      </div>
      
      <!-- Market Section -->
      <div id="marketSection" class="section">
        <h3>Market</h3>
        <p>Your Coins for Sale:</p>
        <div id="userCoinsForSale">
          <!-- Coins available for sale are listed here -->
        </div>
        <p>Available Listings:</p>
        <div id="marketListings">
          <!-- External market listings are displayed here -->
        </div>
      </div>
      
      <!-- Investment Section -->
      <div id="investmentSection" class="section">
        <h3>Invest in Another Vault</h3>
        <p>(Only Investment and Holdings vaults can receive investments)</p>
        <input type="text" id="investRecipient" placeholder="Recipient Username" /><br/>
        <input type="number" id="investAmount" placeholder="Amount ($)" min="1" /><br/>
        <button onclick="submitInvestment()">Invest</button>
      </div>
      
      <!-- Conversion Section -->
      <div id="conversionSection" class="section">
        <h3>Convert Coins to Cash</h3>
        <button onclick="convertCoinsToCash()">Convert Coins</button>
        <p id="conversionNotice" style="color: orange; font-size:10px;"></p>
      </div>
      
      <!-- Guilds & Associations Section -->
      <div id="groupSection" class="section">
        <h3>Guilds & Associations</h3>
        <div id="guildControls">
          <h4>Guild (Holdings Vaults only)</h4>
          <button onclick="createGuild()">Create Guild</button>
          <button onclick="leaveGuild()">Leave Guild</button>
          <div id="guildInfo"><p>Not in a Guild</p></div>
        </div>
        <div id="associationControls">
          <h4>Association (Basic Vaults only)</h4>
          <button onclick="createAssociation()">Create Association</button>
          <button onclick="leaveAssociation()">Leave Association</button>
          <div id="associationInfo"><p>Not in an Association</p></div>
        </div>
      </div>
      
      <!-- Leaderboards Section -->
      <div id="leaderboardSection" class="section">
        <h3>Leaderboards</h3>
        <select id="leaderboardFilter" onchange="updateLeaderboard()">
          <option value="All">Global</option>
          <option value="Basic">Basic Vaults</option>
          <option value="Investment">Investment Vaults</option>
          <option value="Holdings">Holdings Vaults</option>
        </select>
        <div id="leaderboardContent">
          <!-- Rankings will be displayed here -->
        </div>
      </div>
      
    </div>
  </div>
  
  <footer>
    <p>&copy; 2025 Vault Street</p>
  </footer>
  
  <!-- Audio Elements -->
  <audio id="bgMusic" loop>
    <source src="bg-music.mp3" type="audio/mpeg">
  </audio>
  <audio id="sfxMint">
    <source src="sfx-mint.mp3" type="audio/mpeg">
  </audio>
  
  <script>
    /***************************************
     * Firebase Initialization
     ***************************************/
    const firebaseConfig = {
      apiKey: "AIzaSyDfZZUf2pY9ueCx6Q7m86dnitU_voims-8",
      authDomain: "coin-flip-4a693.firebaseapp.com",
      databaseURL: "https://coin-flip-4a693-default-rtdb.firebaseio.com",
      projectId: "coin-flip-4a693",
      storageBucket: "coin-flip-4a693.appspot.com",
      messagingSenderId: "572907715515",
      appId: "1:572907715515:web:68a53fc5a8e4b5157fe29e"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.database();
    
    /***************************************
     * Global Variables & Constants
     ***************************************/
    let currentUsername = "";
    const defaultVaultType = "Basic"; // All new users start as Basic.
    let currentCash = 1000;           // Starting cash.
    let canMint = false;
    let marketPrices = {};            // Dynamically calculated.
    
    // Coin Base Values and Baseline Drop Rates.
    const basePrices = { Copper: 1, Silver: 5, Gold: 10, Platinum: 25, Diamond: 50, Iridium: 75, Rhodium: 100 };
    const baselineDropRates = { Copper: 40, Silver: 25, Gold: 15, Platinum: 10, Diamond: 5, Iridium: 3, Rhodium: 1 };
    
    // Investment parameters.
    const returnRate = 0.10;      // 10% bonus.
    const commissionRate = 0.05;  // 5% commission.
    
    /***************************************
     * Helper Functions
     ***************************************/
    function getRatioColor(ratio) {
      if (ratio < 1.0) return "red";
      else if (ratio > 1.0) return "green";
      else return "yellow";
    }
    // Rarity selection.
    function getRarity() {
      const roll = Math.random() * 100;
      if (roll < 50) return "Copper";
      else if (roll < 75) return "Silver";
      else if (roll < 87) return "Gold";
      else if (roll < 94) return "Platinum";
      else if (roll < 97) return "Diamond";
      else if (roll < 99) return "Iridium";
      else return "Rhodium";
    }
    
    /***************************************
     * Vault Clock System (Cycle: 5 minutes for demo)
     ***************************************/
    const cycleLength = 300; // seconds.
    let clockStartTime = Date.now();
    function updateVaultClock() {
      const elapsed = Math.floor((Date.now() - clockStartTime) / 1000);
      let remaining = cycleLength - (elapsed % cycleLength);
      const minutes = Math.floor(remaining / 60);
      const seconds = remaining % 60;
      document.getElementById("vaultClockDisplay").textContent =
        "Vault Clock: " + minutes.toString().padStart(2, "0") + ":" + seconds.toString().padStart(2, "0");
      if (elapsed % cycleLength === 0) {
        vaultClockReset();
      }
    }
    function vaultClockReset() {
      console.log("Vault Clock Reset Triggered");
      // 1. Return unsold market listings.
      processMarketListingsReturn();
      // 2. Process investments.
      updateAllInvestments();
      // 3. Reset coin conversion eligibility (each vault can convert only 10% of coins per cycle).
      // (For simplicity, we record a "lastConversion" timestamp in the user record.)
      checkVaultUpgrade();
      updateMintedStats();
    }
    setInterval(updateVaultClock, 1000);
    updateVaultClock();
    
    /***************************************
     * Vault Theme Customization
     ***************************************/
    function updateVaultTheme() {
      const theme = document.getElementById("vaultTheme").value;
      const userPanel = document.getElementById("user-panel");
      switch(theme) {
        case "red": userPanel.style.backgroundColor = "#330000"; break;
        case "blue": userPanel.style.backgroundColor = "#000033"; break;
        case "green": userPanel.style.backgroundColor = "#003300"; break;
        default: userPanel.style.backgroundColor = "#1a1a1a";
      }
      if (auth.currentUser) {
        db.ref("users/" + auth.currentUser.uid).update({ theme: theme });
      }
      // PLACE BLOCK HERE: Update dynamic theme pricing in the future.
    }
    
    /***************************************
     * Authentication & User Initialization
     ***************************************/
    auth.onAuthStateChanged(user => {
      if (user) {
        document.getElementById("auth-panel").style.display = "none";
        document.getElementById("user-panel").style.display = "block";
        db.ref("users/" + user.uid).once("value").then(snap => {
          let data = snap.val() || {};
          if (!data.vaultType) {
            data.vaultType = defaultVaultType;
            db.ref("users/" + user.uid).update({ vaultType: defaultVaultType });
          }
          if (!data.cash) {
            data.cash = currentCash;
            db.ref("users/" + user.uid).update({ cash: currentCash });
          }
          if (!data.theme) {
            data.theme = "default";
            db.ref("users/" + user.uid).update({ theme: "default" });
          }
          document.getElementById("vaultTypeDisplay").textContent = data.vaultType;
          currentCash = data.cash;
          // Round cash to one decimal place.
          document.getElementById("cashDisplay").textContent = Number(currentCash).toFixed(1);
          currentUsername = data.username || "";
          if (!currentUsername) {
            currentUsername = document.getElementById("username").value.trim() || user.email.split("@")[0];
            db.ref("users/" + user.uid).update({ username: currentUsername });
          }
          document.getElementById("displayName").textContent = currentUsername;
          // Admin check.
          if (user.email === "stewmin20k@gmail.com") {
            currentUsername = "stewmin";
            db.ref("users/" + user.uid).update({ username: "stewmin" });
            document.getElementById("adminPanel").style.display = "block";
          } else {
            document.getElementById("adminPanel").style.display = "none";
          }
          updateMintAccess();
          loadVault();
          loadUserCoinsForSale();
          updateMarketListings();
          updateLeaderboard();
        });
      } else {
        document.getElementById("auth-panel").style.display = "block";
        document.getElementById("user-panel").style.display = "none";
      }
    });
    function login() {
      const email = document.getElementById("email").value;
      const pass = document.getElementById("password").value;
      const usernameInput = document.getElementById("username").value.trim();
      auth.signInWithEmailAndPassword(email, pass).catch(() => {
        auth.createUserWithEmailAndPassword(email, pass)
          .then(cred => {
            currentUsername = usernameInput || email.split("@")[0];
            db.ref("users/" + cred.user.uid).set({
              email: cred.user.email,
              username: currentUsername,
              vaultType: defaultVaultType,
              cash: currentCash,
              theme: "default",
              coins: {},
              investmentsReceived: {},
              investmentsSent: {},
              lastConversion: 0,
              guild: null,
              association: null
            });
          })
          .catch(err => alert(err.message));
      });
    }
    function logout() {
      auth.signOut();
    }
    
    /***************************************
     * Admin Functions
     ***************************************/
    function adminResetMarket() {
      const user = auth.currentUser;
      if (user && user.email === "stewmin20k@gmail.com" && currentUsername === "stewmin") {
        db.ref("tradeStats").update({ averageTradeRatio: 1.0 });
        alert("Market reset by admin.");
        updateMintAccess();
      } else {
        alert("Admin access required.");
      }
    }
    function adminClearCoinHistory() {
      const user = auth.currentUser;
      if (user && user.email === "stewmin20k@gmail.com" && currentUsername === "stewmin") {
        if (confirm("Clear all coin history? This cannot be undone.")) {
          db.ref("mintRegistry").remove();
          db.ref("marketListings").remove();
          db.ref("users").once("value").then(snapshot => {
            snapshot.forEach(userSnap => {
              db.ref("users/" + userSnap.key + "/coins").remove();
            });
          });
          alert("Coin history cleared.");
          updateMintedStats();
          loadVault();
          updateMarketListings();
        }
      } else {
        alert("Admin access required.");
      }
    }
    
    /***************************************
     * Coin Minting & Vault Functions
     ***************************************/
    const registryRef = db.ref("mintRegistry");
    const mintedRef = db.ref("mintedCount");
    function updateMintAccess() {
      // For demo, minting is enabled.
      canMint = true;
      document.getElementById("mintBtn").disabled = !canMint;
      document.getElementById("mintNotice").style.display = canMint ? "none" : "block";
    }
    function mintNewCoin(callback) {
      const user = auth.currentUser;
      if (!user || !canMint) return;
      mintedRef.once("value").then(snap => {
        const serial = (snap.val() || 0) + 1;
        const rarity = getRarity();
        const now = new Date().toISOString();
        const lockedPrice = marketPrices[rarity] || basePrices[rarity];
        const coinData = { serial, rarity, date: now, price: lockedPrice };
        registryRef.child("coin_" + serial).set(coinData);
        db.ref("users/" + user.uid + "/coins").child("coin_" + serial).set(coinData);
        mintedRef.set(serial);
        playSFX('sfxMint');
        if (callback) callback();
        updateMintedStats();
        loadVault();
        loadUserCoinsForSale();
      });
    }
    function loadVault() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid + "/coins").once("value").then(snap => {
        const data = snap.val() || {};
        const counts = { Copper: 0, Silver: 0, Gold: 0, Platinum: 0, Diamond: 0, Iridium: 0, Rhodium: 0 };
        let summary = "";
        for (const coinId in data) {
          const coin = data[coinId];
          if (coin && coin.rarity) {
            counts[coin.rarity] = (counts[coin.rarity] || 0) + 1;
          }
        }
        for (const r in counts) {
          // Prepend a spinning coin icon.
          summary += `<p><span class="coin-icon coin-${r.toLowerCase()}"></span>${r}: ${counts[r]}</p>`;
        }
        document.getElementById("vaultCoins").innerHTML = summary;
        updateVaultRatio();
      });
    }
    function updateVaultRatio() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users").once("value").then(snapshot => {
        let totalScore = 0, countUsers = 0;
        snapshot.forEach(userSnap => {
          const uData = userSnap.val();
          const coinScore = calculateVaultScore(uData.coins);
          const cashScore = (uData.cash || 0) / 1000;
          totalScore += (coinScore + cashScore);
          countUsers++;
        });
        const avgScore = countUsers ? (totalScore / countUsers) : 0;
        db.ref("users/" + user.uid + "/coins").once("value").then(snap => {
          const currentScore = calculateVaultScore(snap.val()) + (currentCash / 1000);
          const ratio = avgScore ? (currentScore / avgScore) : 1;
          const vaultRatioEl = document.getElementById("vaultRatio");
          vaultRatioEl.textContent = "My Vault Ratio: " + ratio.toFixed(2);
          vaultRatioEl.style.color = getRatioColor(ratio);
        });
      });
    }
    function calculateVaultScore(coins) {
      if (!coins) return 0;
      const rarityValues = { Copper: 1, Silver: 2, Gold: 3, Platinum: 4, Diamond: 5, Iridium: 6, Rhodium: 7 };
      let score = 0, owned = new Set();
      Object.values(coins).forEach(c => {
        if (c && c.rarity) {
          score += rarityValues[c.rarity] || 0;
          owned.add(c.rarity);
        }
      });
      if (owned.size === 7) score += 5;
      return score;
    }
    function updateMintedStats() {
      db.ref("mintRegistry").once("value").then(snap => {
        const data = snap.val() || {};
        const totalCount = Object.keys(data).length;
        let todayCount = 0;
        const todayStr = new Date().toISOString().split("T")[0];
        for (const key in data) {
          if (data[key].date && data[key].date.split("T")[0] === todayStr) todayCount++;
        }
        document.getElementById("totalMinted").textContent = "Total Minted: " + totalCount + " coins";
        document.getElementById("todayMinted").textContent = "Minted Today: " + todayCount + " coins";
      });
    }
    setInterval(updateMintedStats, 60000);
    updateMintedStats();
    
    /***************************************
     * Market Price System ‚Äì Coin Value Calculation
     ***************************************/
    function updateMarketPrices() {
      db.ref("mintRegistry").once("value").then(snap => {
        const regData = snap.val() || {};
        let mintedTotal = { Copper: 0, Silver: 0, Gold: 0, Platinum: 0, Diamond: 0, Iridium: 0, Rhodium: 0 };
        let mintedToday = { Copper: 0, Silver: 0, Gold: 0, Platinum: 0, Diamond: 0, Iridium: 0, Rhodium: 0 };
        const todayStr = new Date().toISOString().split("T")[0];
        for (const key in regData) {
          const coin = regData[key];
          if (coin && coin.rarity) {
            mintedTotal[coin.rarity] = (mintedTotal[coin.rarity] || 0) + 1;
            if (coin.date && coin.date.split("T")[0] === todayStr) {
              mintedToday[coin.rarity] = (mintedToday[coin.rarity] || 0) + 1;
            }
          }
        }
        let sumToday = 0;
        for (const r in mintedToday) {
          sumToday += mintedToday[r];
        }
        let promises = [];
        for (const rarity in basePrices) {
          promises.push(new Promise(resolve => {
            let actualDropRate = sumToday > 0 && mintedToday[rarity]
              ? (mintedToday[rarity] / sumToday) * 100
              : baselineDropRates[rarity];
            db.ref("users").orderByChild("vaultType").equalTo("Holdings").once("value").then(holdSnap => {
              let holdingsCount = 0;
              holdSnap.forEach(child => {
                let coins = child.val().coins;
                if (coins) {
                  Object.values(coins).forEach(c => {
                    if (c.rarity === rarity) holdingsCount++;
                  });
                }
              });
              const totalMintedOverall = mintedTotal[rarity] || 0;
              let scarcityMultiplier = 1;
              if (totalMintedOverall > 0) {
                let percentHoldings = (holdingsCount / totalMintedOverall) * 100;
                scarcityMultiplier = percentHoldings > 0 ? (100 / percentHoldings) : 1;
              }
              let newPrice = basePrices[rarity] * (baselineDropRates[rarity] / actualDropRate) * scarcityMultiplier;
              newPrice = Math.round(newPrice * 100) / 100;
              resolve({ rarity: rarity, price: newPrice, actualDrop: actualDropRate });
            });
          }));
        }
        Promise.all(promises).then(results => {
          results.forEach(res => {
            marketPrices[res.rarity] = res.price;
          });
          updateMarketTicker();
        });
      });
    }
    function updateMarketTicker() {
      let txt = "";
      // For each rarity, display coin type (in white) and price (colored according to trend relative to base value)
      for (const r in marketPrices) {
        let price = marketPrices[r];
        let indicator = "‚öñÔ∏è";
        let priceColor = "yellow";
        if (price > basePrices[r]) { indicator = "üî∫"; priceColor = "green"; }
        else if (price < basePrices[r]) { indicator = "üîª"; priceColor = "red"; }
        txt += `<span style="color: white;">${r}:</span> <span style="color: ${priceColor};">$${price.toFixed(2)}</span> ${indicator} | `;
      }
      document.getElementById("marketPricesText").innerHTML = txt;
    }
    setInterval(updateMarketPrices, 60000);
    updateMarketPrices();
    
    /***************************************
     * Market Listings ‚Äì Sell/Buy
     ***************************************/
    function listCoinForSale(coinId) {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid + "/coins/" + coinId).once("value").then(snap => {
        const coinData = snap.val();
        if (!coinData) return;
        let listing = {
          coin: coinData,
          sellerUid: user.uid,
          listedAt: Date.now(),
          fulfilled: false
        };
        db.ref("marketListings").push(listing, err => {
          if (!err) {
            db.ref("users/" + user.uid + "/coins/" + coinId).remove();
            loadVault();
            loadUserCoinsForSale();
            updateMarketListings();
          }
        });
      });
    }
    function loadUserCoinsForSale() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid + "/coins").once("value").then(snap => {
        const data = snap.val() || {};
        let html = "";
        for (const id in data) {
          const coin = data[id];
          html += `<p><span class="coin-icon coin-${coin.rarity.toLowerCase()}"></span>${coin.rarity} (Coin #${coin.serial}) <button onclick="listCoinForSale('${id}')">List for Sale</button></p>`;
        }
        document.getElementById("userCoinsForSale").innerHTML = html || "<p>No coins available for sale.</p>";
      });
    }
    function updateMarketListings() {
      db.ref("marketListings").orderByChild("listedAt").once("value").then(snap => {
        const listings = snap.val() || {};
        let html = "";
        for (const key in listings) {
          const lst = listings[key];
          if (lst.fulfilled) continue;
          html += `<div class="listing">
                     <p><span class="coin-icon coin-${lst.coin.rarity.toLowerCase()}"></span>${lst.coin.rarity} (Coin #${lst.coin.serial}) ‚Äì Price: $${lst.coin.price.toFixed(2)}</p>
                     <p>Seller: ${lst.sellerUid}</p>
                     <button onclick="buyMarketCoin('${key}', ${lst.coin.price})">Buy</button>
                   </div>`;
        }
        document.getElementById("marketListings").innerHTML = html || "<p>No active listings.</p>";
      });
    }
    function buyMarketCoin(listingId, price) {
      const buyer = auth.currentUser;
      if (!buyer) return;
      db.ref("users/" + buyer.uid).once("value").then(snap => {
        const buyerData = snap.val();
        if (buyerData.cash < price) {
          alert("Insufficient cash to purchase coin.");
          return;
        }
        let newCash = buyerData.cash - price;
        db.ref("users/" + buyer.uid).update({ cash: newCash });
        db.ref("marketListings/" + listingId).once("value").then(snapListing => {
          const listing = snapListing.val();
          if (!listing || listing.fulfilled) return;
          db.ref("users/" + buyer.uid + "/coins").push(listing.coin);
          db.ref("marketListings/" + listingId).update({ fulfilled: true });
          updateUserCash();
          updateMarketListings();
          loadVault();
        });
      });
    }
    function processMarketListingsReturn() {
      db.ref("marketListings").once("value").then(snap => {
        const listings = snap.val() || {};
        for (const key in listings) {
          const lst = listings[key];
          if (!lst.fulfilled && Date.now() - lst.listedAt >= cycleLength * 1000) {
            db.ref("users/" + lst.sellerUid + "/coins").push(lst.coin);
            db.ref("marketListings/" + key).remove();
          }
        }
        updateMarketListings();
      });
    }
    setInterval(updateMarketListings, 30000);
    
    /***************************************
     * Investment System
     ***************************************/
    function submitInvestment() {
      const investor = auth.currentUser;
      if (!investor) return;
      const recipientName = document.getElementById("investRecipient").value.trim();
      const amount = parseFloat(document.getElementById("investAmount").value);
      if (!recipientName || isNaN(amount) || amount <= 0) {
        alert("Enter a valid recipient and amount.");
        return;
      }
      db.ref("users/" + investor.uid).once("value").then(snap => {
        const invData = snap.val();
        if (invData.cash < amount) {
          alert("Insufficient cash for investment.");
          return;
        }
        db.ref("users").orderByChild("username").equalTo(recipientName).once("value").then(snap2 => {
          if (!snap2.exists()) {
            alert("Recipient not found.");
            return;
          }
          let recipientUid = "";
          let recipientData = {};
          snap2.forEach(childSnap => {
            recipientUid = childSnap.key;
            recipientData = childSnap.val();
          });
          if (recipientData.vaultType === "Basic") {
            alert("Recipient vault is Basic and cannot receive investments.");
            return;
          }
          let newCash = invData.cash - amount;
          db.ref("users/" + investor.uid).update({ cash: newCash });
          db.ref("users/" + recipientUid + "/investmentsReceived").push({
            from: currentUsername,
            amount: amount,
            timestamp: Date.now(),
            processed: false
          });
          alert("Invested $" + amount + " in " + recipientName + ".");
          updateUserCash();
        });
      });
    }
    function updateUserCash() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid + "/cash").once("value").then(snap => {
        currentCash = snap.val() || 0;
        document.getElementById("cashDisplay").textContent = Number(currentCash).toFixed(1);
      });
    }
    function updateAllInvestments() {
      db.ref("users").once("value").then(snapshot => {
        snapshot.forEach(userSnap => {
          const uid = userSnap.key;
          const uData = userSnap.val();
          if (uData.investmentsReceived) {
            Object.keys(uData.investmentsReceived).forEach(inv => {
              const investment = uData.investmentsReceived[inv];
              if (!investment.processed) {
                // For demo purposes, assume market activity ratio = 1.0.
                let bonus = investment.amount * returnRate;
                let commission = bonus * commissionRate;
                let newCash = (uData.cash || 0) + bonus + commission;
                db.ref("users/" + uid).update({ cash: newCash });
                db.ref("users/" + uid + "/investmentsReceived/" + inv).update({ processed: true });
              }
            });
          }
        });
      });
    }
    
    /***************************************
     * Coin-to-Cash Conversion
     * Basic & Investment vaults: convert 10% of total coin count per cycle.
     * Holdings vault: convert all coins if total coin value > cash.
     ***************************************/
    function convertCoinsToCash() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid).once("value").then(snap => {
        const data = snap.val();
        let lastConv = data.lastConversion || 0;
        let currentCycleStart = clockStartTime + Math.floor((Date.now() - clockStartTime) / (cycleLength * 1000)) * (cycleLength * 1000);
        if (lastConv > currentCycleStart) {
          document.getElementById("conversionNotice").textContent = "Conversion already done this cycle.";
          return;
        }
        db.ref("users/" + user.uid + "/coins").once("value").then(snapCoins => {
          let coins = snapCoins.val() || {};
          let coinIds = Object.keys(coins);
          let count = coinIds.length;
          if (data.vaultType === "Holdings") {
            // Holdings: convert all if coin value > cash.
            let totalCoinValue = 0;
            Object.values(coins).forEach(coin => {
              if (coin && coin.rarity && marketPrices[coin.rarity]) {
                totalCoinValue += marketPrices[coin.rarity];
              }
            });
            if (totalCoinValue <= data.cash) {
              document.getElementById("conversionNotice").textContent = "Conversion not needed: Cash exceeds coin value.";
              return;
            }
            // Convert all coins.
            conversionProcess(user, coinIds, totalCoinValue);
          } else {
            // Basic and Investment: can convert only 10% of coin count (rounded down)
            const limit = Math.floor(count * 0.10);
            if (limit < 1) {
              document.getElementById("conversionNotice").textContent = "Not enough coins to convert this cycle.";
              return;
            }
            let selectedCoinIds = coinIds.slice(0, limit);
            let convValue = 0;
            selectedCoinIds.forEach(id => {
              let coin = coins[id];
              if (coin && coin.rarity && marketPrices[coin.rarity]) {
                convValue += marketPrices[coin.rarity];
              }
            });
            conversionProcess(user, selectedCoinIds, convValue);
          }
        });
      });
    }
    function conversionProcess(user, coinIdArray, convValue) {
      db.ref("users/" + user.uid + "/coins").remove().then(() => {
        db.ref("users/" + user.uid).update({ cash: dataCashUpdate(user, convValue), lastConversion: Date.now() });
        updateUserCash();
        document.getElementById("conversionNotice").textContent = "Converted $" + convValue.toFixed(1) + " from coins.";
        loadVault();
        loadUserCoinsForSale();
      });
    }
    function dataCashUpdate(user, convValue) {
      // Update cash adding conversion amount, rounded to 1 decimal place.
      return Number((currentCash + convValue).toFixed(1));
    }
    
    /***************************************
     * Leaderboard System
     ***************************************/
    function updateLeaderboard() {
      const filter = document.getElementById("leaderboardFilter").value;
      db.ref("users").once("value").then(snapshot => {
        let leaderboardArr = [];
        snapshot.forEach(userSnap => {
          const uData = userSnap.val();
          if (filter !== "All" && uData.vaultType !== filter) return;
          const coinScore = calculateVaultScore(uData.coins);
          const cashScore = (uData.cash || 0) / 1000;
          let totalScore = coinScore + cashScore;
          leaderboardArr.push({ username: uData.username || "Unknown", score: totalScore });
        });
        leaderboardArr.sort((a, b) => b.score - a.score);
        let html = "";
        leaderboardArr.slice(0, 10).forEach((entry, index) => {
          html += `<p>${index + 1}. ${entry.username}: ${entry.score.toFixed(2)}</p>`;
        });
        document.getElementById("leaderboardContent").innerHTML = html;
      });
    }
    setInterval(updateLeaderboard, 60000);
    updateLeaderboard();
    
    /***************************************
     * Guilds & Associations ‚Äì Full Implementation
     ***************************************/
    // Guilds: Only Holdings Vaults may form a Guild.
    function createGuild() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid).once("value").then(snap => {
        const uData = snap.val();
        if (uData.vaultType !== "Holdings") {
          alert("Only Holdings Vaults can form a Guild.");
          return;
        }
        let guildName = prompt("Enter Guild Name:");
        if (!guildName) return;
        let guildData = {
          name: guildName,
          leader: user.uid,
          coLeaders: [],
          members: [],
          associates: [],
          createdAt: Date.now()
        };
        db.ref("guilds").push(guildData, err => {
          if (!err) {
            db.ref("users/" + user.uid).update({ guild: guildName });
            document.getElementById("guildInfo").innerHTML = `<p>Guild: ${guildName}</p>`;
          }
        });
      });
    }
    function leaveGuild() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid).update({ guild: null });
      document.getElementById("guildInfo").innerHTML = "<p>Not in a Guild</p>";
    }
    // Associations: Only Basic Vaults may form Associations.
    function createAssociation() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid).once("value").then(snap => {
        const uData = snap.val();
        if (uData.vaultType !== "Basic") {
          alert("Only Basic Vaults can form an Association.");
          return;
        }
        let assocName = prompt("Enter Association Name:");
        if (!assocName) return;
        let assocData = {
          name: assocName,
          leader: user.uid,
          members: [],
          createdAt: Date.now()
        };
        db.ref("associations").push(assocData, err => {
          if (!err) {
            db.ref("users/" + user.uid).update({ association: assocName });
            document.getElementById("associationInfo").innerHTML = `<p>Association: ${assocName}</p>`;
          }
        });
      });
    }
    function leaveAssociation() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid).update({ association: null });
      document.getElementById("associationInfo").innerHTML = "<p>Not in an Association</p>";
    }
    
    /***************************************
     * Vault Upgrades ‚Äì Progression
     * Upgrade Criteria:
     *  Basic -> Investment: cash >= 5000 AND >= 3 investments received.
     *  Investment -> Holdings: cash >= 10000 AND >= 5 investments received.
     ***************************************/
    function checkVaultUpgrade() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid).once("value").then(snap => {
        let uData = snap.val();
        let invCount = uData.investmentsReceived ? Object.keys(uData.investmentsReceived).length : 0;
        if (uData.vaultType === "Basic" && uData.cash >= 5000 && invCount >= 3) {
          db.ref("users/" + user.uid).update({ vaultType: "Investment" });
          document.getElementById("vaultTypeDisplay").textContent = "Investment";
          alert("Congratulations! Your vault has been upgraded to Investment Vault.");
        } else if (uData.vaultType === "Investment" && uData.cash >= 10000 && invCount >= 5) {
          db.ref("users/" + user.uid).update({ vaultType: "Holdings" });
          document.getElementById("vaultTypeDisplay").textContent = "Holdings";
          alert("Congratulations! Your vault has been upgraded to Holdings Vault.");
        }
      });
    }
    
    /***************************************
     * Marketplace ‚Äì Sell/Buy
     ***************************************/
    function listCoinForSale(coinId) {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid + "/coins/" + coinId).once("value").then(snap => {
        const coinData = snap.val();
        if (!coinData) return;
        let listing = {
          coin: coinData,
          sellerUid: user.uid,
          listedAt: Date.now(),
          fulfilled: false
        };
        db.ref("marketListings").push(listing, err => {
          if (!err) {
            db.ref("users/" + user.uid + "/coins/" + coinId).remove();
            loadVault();
            loadUserCoinsForSale();
            updateMarketListings();
          }
        });
      });
    }
    function loadUserCoinsForSale() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid + "/coins").once("value").then(snap => {
        const data = snap.val() || {};
        let html = "";
        for (const id in data) {
          const coin = data[id];
          html += `<p><span class="coin-icon coin-${coin.rarity.toLowerCase()}"></span>${coin.rarity} (Coin #${coin.serial}) <button onclick="listCoinForSale('${id}')">List for Sale</button></p>`;
        }
        document.getElementById("userCoinsForSale").innerHTML = html || "<p>No coins available for sale.</p>";
      });
    }
    function updateMarketListings() {
      db.ref("marketListings").orderByChild("listedAt").once("value").then(snap => {
        const listings = snap.val() || {};
        let html = "";
        for (const key in listings) {
          const lst = listings[key];
          if (lst.fulfilled) continue;
          html += `<div class="listing">
                     <p><span class="coin-icon coin-${lst.coin.rarity.toLowerCase()}"></span>${lst.coin.rarity} (Coin #${lst.coin.serial}) ‚Äì Price: $${lst.coin.price.toFixed(2)}</p>
                     <p>Seller: ${lst.sellerUid}</p>
                     <button onclick="buyMarketCoin('${key}', ${lst.coin.price})">Buy</button>
                   </div>`;
        }
        document.getElementById("marketListings").innerHTML = html || "<p>No active listings.</p>";
      });
    }
    function buyMarketCoin(listingId, price) {
      const buyer = auth.currentUser;
      if (!buyer) return;
      db.ref("users/" + buyer.uid).once("value").then(snap => {
        const buyerData = snap.val();
        if (buyerData.cash < price) {
          alert("Insufficient cash to purchase coin.");
          return;
        }
        let newCash = buyerData.cash - price;
        db.ref("users/" + buyer.uid).update({ cash: newCash });
        db.ref("marketListings/" + listingId).once("value").then(snapListing => {
          const listing = snapListing.val();
          if (!listing || listing.fulfilled) return;
          db.ref("users/" + buyer.uid + "/coins").push(listing.coin);
          db.ref("marketListings/" + listingId).update({ fulfilled: true });
          updateUserCash();
          updateMarketListings();
          loadVault();
        });
      });
    }
    function processMarketListingsReturn() {
      db.ref("marketListings").once("value").then(snap => {
        const listings = snap.val() || {};
        for (const key in listings) {
          const lst = listings[key];
          if (!lst.fulfilled && Date.now() - lst.listedAt >= cycleLength * 1000) {
            db.ref("users/" + lst.sellerUid + "/coins").push(lst.coin);
            db.ref("marketListings/" + key).remove();
          }
        }
        updateMarketListings();
      });
    }
    setInterval(updateMarketListings, 30000);
    
    /***************************************
     * Coin-to-Cash Conversion (Updated)
     * Basic & Investment: Only convert 10% of coin count per cycle.
     * Holdings: Convert all coins if their total market value > current cash.
     ***************************************/
    function convertCoinsToCash() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid).once("value").then(snap => {
        const data = snap.val();
        let lastConv = data.lastConversion || 0;
        let currentCycleStart = clockStartTime + Math.floor((Date.now() - clockStartTime) / (cycleLength * 1000)) * (cycleLength * 1000);
        if (lastConv > currentCycleStart) {
          document.getElementById("conversionNotice").textContent = "Conversion already done this cycle.";
          return;
        }
        db.ref("users/" + user.uid + "/coins").once("value").then(snapCoins => {
          let coins = snapCoins.val() || {};
          let coinIds = Object.keys(coins);
          let totalCoinValue = 0;
          Object.values(coins).forEach(coin => {
            if (coin && coin.rarity && marketPrices[coin.rarity]) {
              totalCoinValue += marketPrices[coin.rarity];
            }
          });
          let cash = data.cash || 0;
          if (data.vaultType === "Holdings") {
            if (totalCoinValue <= cash) {
              document.getElementById("conversionNotice").textContent = "Conversion not needed: Cash exceeds coin value.";
              return;
            }
            conversionProcess(user, coinIds, totalCoinValue);
          } else {
            // Limit conversion to 10% of coin count.
            const convCount = Math.floor(coinIds.length * 0.10);
            if (convCount < 1) {
              document.getElementById("conversionNotice").textContent = "Not enough coins to convert this cycle.";
              return;
            }
            let selected = coinIds.slice(0, convCount);
            let convValue = 0;
            selected.forEach(id => {
              let coin = coins[id];
              if (coin && coin.rarity && marketPrices[coin.rarity]) {
                convValue += marketPrices[coin.rarity];
              }
            });
            conversionProcess(user, selected, convValue);
          }
        });
      });
    }
    function conversionProcess(user, coinIdArray, convValue) {
      db.ref("users/" + user.uid + "/coins").once("value").then(snap => {
        let coins = snap.val() || {};
        // Remove only the coins in coinIdArray.
        coinIdArray.forEach(id => {
          db.ref("users/" + user.uid + "/coins/" + id).remove();
        });
        // Update cash rounded to 1 decimal place.
        let newCash = Number((currentCash + convValue).toFixed(1));
        db.ref("users/" + user.uid).update({ cash: newCash, lastConversion: Date.now() });
        currentCash = newCash;
        document.getElementById("cashDisplay").textContent = newCash.toFixed(1);
        document.getElementById("conversionNotice").textContent = "Converted $" + convValue.toFixed(1) + " from coins.";
        loadVault();
        loadUserCoinsForSale();
      });
    }
    
    /***************************************
     * Leaderboard System
     ***************************************/
    function updateLeaderboard() {
      const filter = document.getElementById("leaderboardFilter").value;
      db.ref("users").once("value").then(snapshot => {
        let leaderboardArr = [];
        snapshot.forEach(userSnap => {
          const uData = userSnap.val();
          if (filter !== "All" && uData.vaultType !== filter) return;
          const coinScore = calculateVaultScore(uData.coins);
          const cashScore = (uData.cash || 0) / 1000;
          let totalScore = coinScore + cashScore;
          leaderboardArr.push({ username: uData.username || "Unknown", score: totalScore });
        });
        leaderboardArr.sort((a, b) => b.score - a.score);
        let html = "";
        leaderboardArr.slice(0, 10).forEach((entry, index) => {
          html += `<p>${index+1}. ${entry.username}: ${entry.score.toFixed(2)}</p>`;
        });
        document.getElementById("leaderboardContent").innerHTML = html;
      });
    }
    setInterval(updateLeaderboard, 60000);
    updateLeaderboard();
    
    /***************************************
     * Guilds & Associations ‚Äì Full Implementation
     ***************************************/
    // Guild Functions (Holdings Vaults only)
    function createGuild() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid).once("value").then(snap => {
        const uData = snap.val();
        if (uData.vaultType !== "Holdings") {
          alert("Only Holdings Vaults can form a Guild.");
          return;
        }
        let guildName = prompt("Enter Guild Name:");
        if (!guildName) return;
        let guildData = {
          name: guildName,
          leader: user.uid,
          coLeaders: [],
          members: [],
          associates: [],
          createdAt: Date.now()
        };
        db.ref("guilds").push(guildData, err => {
          if (!err) {
            db.ref("users/" + user.uid).update({ guild: guildName });
            document.getElementById("guildInfo").innerHTML = `<p>Guild: ${guildName}</p>`;
          }
        });
      });
    }
    function leaveGuild() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid).update({ guild: null });
      document.getElementById("guildInfo").innerHTML = "<p>Not in a Guild</p>";
    }
    // Association Functions (Basic Vaults only)
    function createAssociation() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid).once("value").then(snap => {
        const uData = snap.val();
        if (uData.vaultType !== "Basic") {
          alert("Only Basic Vaults can form an Association.");
          return;
        }
        let assocName = prompt("Enter Association Name:");
        if (!assocName) return;
        let assocData = {
          name: assocName,
          leader: user.uid,
          members: [],
          createdAt: Date.now()
        };
        db.ref("associations").push(assocData, err => {
          if (!err) {
            db.ref("users/" + user.uid).update({ association: assocName });
            document.getElementById("associationInfo").innerHTML = `<p>Association: ${assocName}</p>`;
          }
        });
      });
    }
    function leaveAssociation() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid).update({ association: null });
      document.getElementById("associationInfo").innerHTML = "<p>Not in an Association</p>";
    }
    
    /***************************************
     * Vault Upgrades ‚Äì Progression
     * Basic -> Investment: if cash >= $5000 and investments received >= 3.
     * Investment -> Holdings: if cash >= $10000 and investments received >= 5.
     ***************************************/
    function checkVaultUpgrade() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid).once("value").then(snap => {
        let uData = snap.val();
        let invCount = uData.investmentsReceived ? Object.keys(uData.investmentsReceived).length : 0;
        if (uData.vaultType === "Basic" && uData.cash >= 5000 && invCount >= 3) {
          db.ref("users/" + user.uid).update({ vaultType: "Investment" });
          document.getElementById("vaultTypeDisplay").textContent = "Investment";
          alert("Vault upgraded to Investment Vault.");
        } else if (uData.vaultType === "Investment" && uData.cash >= 10000 && invCount >= 5) {
          db.ref("users/" + user.uid).update({ vaultType: "Holdings" });
          document.getElementById("vaultTypeDisplay").textContent = "Holdings";
          alert("Vault upgraded to Holdings Vault.");
        }
      });
    }
    
    /***************************************
     * Marketplace ‚Äì Sell/Buy
     ***************************************/
    function listCoinForSale(coinId) {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid + "/coins/" + coinId).once("value").then(snap => {
        const coinData = snap.val();
        if (!coinData) return;
        let listing = {
          coin: coinData,
          sellerUid: user.uid,
          listedAt: Date.now(),
          fulfilled: false
        };
        db.ref("marketListings").push(listing, err => {
          if (!err) {
            db.ref("users/" + user.uid + "/coins/" + coinId).remove();
            loadVault();
            loadUserCoinsForSale();
            updateMarketListings();
          }
        });
      });
    }
    function updateMarketListings() {
      db.ref("marketListings").orderByChild("listedAt").once("value").then(snap => {
        const listings = snap.val() || {};
        let html = "";
        for (const key in listings) {
          const lst = listings[key];
          if (lst.fulfilled) continue;
          html += `<div class="listing">
                     <p><span class="coin-icon coin-${lst.coin.rarity.toLowerCase()}"></span>${lst.coin.rarity} (Coin #${lst.coin.serial}) ‚Äì Price: $${lst.coin.price.toFixed(2)}</p>
                     <p>Seller: ${lst.sellerUid}</p>
                     <button onclick="buyMarketCoin('${key}', ${lst.coin.price})">Buy</button>
                   </div>`;
        }
        document.getElementById("marketListings").innerHTML = html || "<p>No active listings.</p>";
      });
    }
    function buyMarketCoin(listingId, price) {
      const buyer = auth.currentUser;
      if (!buyer) return;
      db.ref("users/" + buyer.uid).once("value").then(snap => {
        const buyerData = snap.val();
        if (buyerData.cash < price) {
          alert("Insufficient cash.");
          return;
        }
        let newCash = buyerData.cash - price;
        db.ref("users/" + buyer.uid).update({ cash: newCash });
        db.ref("marketListings/" + listingId).once("value").then(snapListing => {
          const listing = snapListing.val();
          if (!listing || listing.fulfilled) return;
          db.ref("users/" + buyer.uid + "/coins").push(listing.coin);
          db.ref("marketListings/" + listingId).update({ fulfilled: true });
          updateUserCash();
          updateMarketListings();
          loadVault();
        });
      });
    }
    function processMarketListingsReturn() {
      db.ref("marketListings").once("value").then(snap => {
        const listings = snap.val() || {};
        for (const key in listings) {
          const lst = listings[key];
          if (!lst.fulfilled && Date.now() - lst.listedAt >= cycleLength * 1000) {
            db.ref("users/" + lst.sellerUid + "/coins").push(lst.coin);
            db.ref("marketListings/" + key).remove();
          }
        }
        updateMarketListings();
      });
    }
    setInterval(updateMarketListings, 30000);
    
    /***************************************
     * Investment System
     ***************************************/
    function submitInvestment() {
      const investor = auth.currentUser;
      if (!investor) return;
      const recipientName = document.getElementById("investRecipient").value.trim();
      const amount = parseFloat(document.getElementById("investAmount").value);
      if (!recipientName || isNaN(amount) || amount <= 0) {
        alert("Enter valid recipient and amount.");
        return;
      }
      db.ref("users/" + investor.uid).once("value").then(snap => {
        const invData = snap.val();
        if (invData.cash < amount) {
          alert("Insufficient cash.");
          return;
        }
        db.ref("users").orderByChild("username").equalTo(recipientName).once("value").then(snap2 => {
          if (!snap2.exists()) {
            alert("Recipient not found.");
            return;
          }
          let recipientUid = "";
          let recipientData = {};
          snap2.forEach(childSnap => {
            recipientUid = childSnap.key;
            recipientData = childSnap.val();
          });
          if (recipientData.vaultType === "Basic") {
            alert("Recipient vault is Basic and cannot receive investments.");
            return;
          }
          let newCash = invData.cash - amount;
          db.ref("users/" + investor.uid).update({ cash: newCash });
          db.ref("users/" + recipientUid + "/investmentsReceived").push({
            from: currentUsername,
            amount: amount,
            timestamp: Date.now(),
            processed: false
          });
          alert("Investment of $" + amount + " sent to " + recipientName + ".");
          updateUserCash();
        });
      });
    }
    
    /***************************************
     * Coin-to-Cash Conversion (Updated)
     * Basic & Investment: convert 10% of coin count.
     * Holdings: convert all if total coin value > cash.
     ***************************************/
    function convertCoinsToCash() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid).once("value").then(snap => {
        const data = snap.val();
        let lastConv = data.lastConversion || 0;
        let currentCycleStart = clockStartTime + Math.floor((Date.now() - clockStartTime) / (cycleLength * 1000)) * (cycleLength * 1000);
        if (lastConv > currentCycleStart) {
          document.getElementById("conversionNotice").textContent = "Conversion already done this cycle.";
          return;
        }
        db.ref("users/" + user.uid + "/coins").once("value").then(snapCoins => {
          let coins = snapCoins.val() || {};
          let coinIds = Object.keys(coins);
          let totalCoinValue = 0;
          Object.values(coins).forEach(coin => {
            if (coin && coin.rarity && marketPrices[coin.rarity]) {
              totalCoinValue += marketPrices[coin.rarity];
            }
          });
          let cash = data.cash || 0;
          if (data.vaultType === "Holdings") {
            if (totalCoinValue <= cash) {
              document.getElementById("conversionNotice").textContent = "No conversion: Cash exceeds coin value.";
              return;
            }
            conversionProcess(user, coinIds, totalCoinValue);
          } else {
            // Only convert 10% of coins.
            const convCount = Math.floor(coinIds.length * 0.10);
            if (convCount < 1) {
              document.getElementById("conversionNotice").textContent = "Not enough coins to convert this cycle.";
              return;
            }
            let selected = coinIds.slice(0, convCount);
            let convValue = 0;
            selected.forEach(id => {
              let coin = coins[id];
              if (coin && coin.rarity && marketPrices[coin.rarity]) {
                convValue += marketPrices[coin.rarity];
              }
            });
            conversionProcess(user, selected, convValue);
          }
        });
      });
    }
    function conversionProcess(user, coinIdArray, convValue) {
      // Remove only the specified coins.
      coinIdArray.forEach(id => {
        db.ref("users/" + user.uid + "/coins/" + id).remove();
      });
      let newCash = Number((currentCash + convValue).toFixed(1));
      db.ref("users/" + user.uid).update({ cash: newCash, lastConversion: Date.now() });
      currentCash = newCash;
      document.getElementById("cashDisplay").textContent = newCash.toFixed(1);
      document.getElementById("conversionNotice").textContent = "Converted $" + convValue.toFixed(1) + " from coins.";
      loadVault();
      loadUserCoinsForSale();
    }
    
    /***************************************
     * Leaderboard System
     ***************************************/
    function updateLeaderboard() {
      const filter = document.getElementById("leaderboardFilter").value;
      db.ref("users").once("value").then(snapshot => {
        let leaderboardArr = [];
        snapshot.forEach(userSnap => {
          const uData = userSnap.val();
          if (filter !== "All" && uData.vaultType !== filter) return;
          const coinScore = calculateVaultScore(uData.coins);
          const cashScore = (uData.cash || 0) / 1000;
          let totalScore = coinScore + cashScore;
          leaderboardArr.push({ username: uData.username || "Unknown", score: totalScore });
        });
        leaderboardArr.sort((a, b) => b.score - a.score);
        let html = "";
        leaderboardArr.slice(0, 10).forEach((entry, index) => {
          html += `<p>${index+1}. ${entry.username}: ${entry.score.toFixed(2)}</p>`;
        });
        document.getElementById("leaderboardContent").innerHTML = html;
      });
    }
    setInterval(updateLeaderboard, 60000);
    updateLeaderboard();
    
    /***************************************
     * Guilds & Associations ‚Äì Full Implementation
     ***************************************/
    function createGuild() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid).once("value").then(snap => {
        const uData = snap.val();
        if (uData.vaultType !== "Holdings") {
          alert("Only Holdings Vaults can form a Guild.");
          return;
        }
        let guildName = prompt("Enter Guild Name:");
        if (!guildName) return;
        let guildData = {
          name: guildName,
          leader: user.uid,
          coLeaders: [],
          members: [],
          associates: [],
          createdAt: Date.now()
        };
        db.ref("guilds").push(guildData, err => {
          if (!err) {
            db.ref("users/" + user.uid).update({ guild: guildName });
            document.getElementById("guildInfo").innerHTML = `<p>Guild: ${guildName}</p>`;
          }
        });
      });
    }
    function leaveGuild() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid).update({ guild: null });
      document.getElementById("guildInfo").innerHTML = "<p>Not in a Guild</p>";
    }
    function createAssociation() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid).once("value").then(snap => {
        const uData = snap.val();
        if (uData.vaultType !== "Basic") {
          alert("Only Basic Vaults can form an Association.");
          return;
        }
        let assocName = prompt("Enter Association Name:");
        if (!assocName) return;
        let assocData = {
          name: assocName,
          leader: user.uid,
          members: [],
          createdAt: Date.now()
        };
        db.ref("associations").push(assocData, err => {
          if (!err) {
            db.ref("users/" + user.uid).update({ association: assocName });
            document.getElementById("associationInfo").innerHTML = `<p>Association: ${assocName}</p>`;
          }
        });
      });
    }
    function leaveAssociation() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid).update({ association: null });
      document.getElementById("associationInfo").innerHTML = "<p>Not in an Association</p>";
    }
    
    /***************************************
     * Vault Upgrades ‚Äì Progression
     * Basic ‚Üí Investment: if cash >= 5000 and >= 3 investments received.
     * Investment ‚Üí Holdings: if cash >= 10000 and >= 5 investments received.
     ***************************************/
    function checkVaultUpgrade() {
      const user = auth.currentUser;
      if (!user) return;
      db.ref("users/" + user.uid).once("value").then(snap => {
        let uData = snap.val();
        let invCount = uData.investmentsReceived ? Object.keys(uData.investmentsReceived).length : 0;
        if (uData.vaultType === "Basic" && uData.cash >= 5000 && invCount >= 3) {
          db.ref("users/" + user.uid).update({ vaultType: "Investment" });
          document.getElementById("vaultTypeDisplay").textContent = "Investment";
          alert("Vault upgraded to Investment Vault.");
        } else if (uData.vaultType === "Investment" && uData.cash >= 10000 && invCount >= 5) {
          db.ref("users/" + user.uid).update({ vaultType: "Holdings" });
          document.getElementById("vaultTypeDisplay").textContent = "Holdings";
          alert("Vault upgraded to Holdings Vault.");
        }
      });
    }
    
    /***************************************
     * Marketplace ‚Äì Sell/Buy (As before)
     ***************************************/
    // Already defined above in market listings.
    
    /***************************************
     * Leaderboard & Cash Display Precision
     ***************************************/
    // Cash is displayed rounded to one decimal via toFixed(1) in updateUserCash().
    
    /***************************************
     * Spinning Coin Icons implemented in CSS,
     * and added next to coin rarity texts in vaults and listings.
     ***************************************/
    
    /***************************************
     * Audio Controls
     ***************************************/
    let muted = localStorage.getItem("vaultAudioMuted") === "true";
    document.getElementById("bgMusic").muted = muted;
    function toggleAudio() {
      muted = !muted;
      localStorage.setItem("vaultAudioMuted", muted);
      document.getElementById("bgMusic").muted = muted;
    }
    function playSFX(id) {
      const audio = document.getElementById(id);
      if (!muted && audio) {
        audio.pause();
        audio.currentTime = 0;
        audio.play().catch(e => console.warn("Audio error:", e));
      }
    }
    
    /***************************************
     * Marketplace Refresh
     ***************************************/
    setInterval(updateMarketListings, 30000);
    
  </script>
</body>
</html>
