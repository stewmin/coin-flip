<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vault Street ‚Äì Beta Build</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  <!-- Load Firebase libraries -->
  <script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-database-compat.js"></script>
  <style>
    /* Base Styles */
    body { margin: 0; font-family: 'Press Start 2P', cursive; background: #111; color: white; }
    header { text-align: center; background: #000; padding: 20px; border-bottom: 2px solid gold; }
    .container { max-width: 960px; margin: 20px auto; padding: 0 20px; }
    .section { margin-top: 20px; padding: 10px; background: #1a1a1a; border: 1px solid #333; border-radius: 5px; }
    input, button, select { font-family: 'Press Start 2P', cursive; font-size: 10px; padding: 5px; margin: 3px; }
    input, select { background: #ddd; color: #000; }
    footer { text-align: center; background: #000; padding: 20px; font-size: 10px; margin-top: 20px; color: gray; }
    /* Tickers, Notifications, and Leaderboards */
    #notificationsBox { background: #333; padding: 5px; font-size: 10px; text-align: center; }
    #marketTicker marquee, #investmentTicker marquee, #netWorthTicker marquee { background: #222; padding: 5px; font-size: 10px; margin-bottom: 5px; }
    /* Vault Clock */
    #vaultClockDisplay { font-size: 12px; color: cyan; text-align: center; margin-top: 10px; }
    /* Coin Icons */
    .coin-icon { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 3px; animation: spin 2s linear infinite; vertical-align: middle; }
    .coin-copper { background: #b87333; }
    .coin-silver { background: #c0c0c0; }
    .coin-gold { background: #ffd700; }
    .coin-platinum { background: #e5e4e2; }
    .coin-diamond { background: #b9f2ff; }
    .coin-iridium { background: #6a0dad; }
    .coin-rhodium { background: #ff4500; }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    /* Tables */
    #vaultTable { width: 100%; border-collapse: collapse; }
    #vaultTable th, #vaultTable td { border: 1px solid #444; padding: 4px; text-align: center; font-size: 10px; }
    /* Dropdowns */
    #marketDropdown, .groupDropdown, #groupSearch { background: white; color: black; padding: 10px; border: 1px solid #444; border-radius: 5px; margin-top: 10px; }
    /* Static Banner for Coin Value */
    #staticValueTicker { background: #222; color: white; padding: 5px; margin-bottom: 10px; font-size: 10px; text-align: center; }
    /* Additional Tickers */
    #investmentTicker, #netWorthTicker { background: #222; color: white; padding: 5px; margin-bottom: 5px; font-size: 10px; text-align: center; }
  </style>
</head>
<body>
  <header>
    <h1>üèõÔ∏è Vault Street ‚Äì Beta Build</h1>
  </header>
  
  <!-- Notifications -->
  <div id="notificationsBox">
    <button onclick="app.toggleNotifications()">‚úâÔ∏è</button> Notifications: <span id="notificationsContent">None</span>
    <div id="notificationDropdown"></div>
  </div>
  
  <!-- Scrolling Tickers -->
  <div id="marketTicker">
    <marquee id="marketPricesText" scrollamount="6">Coin Values: Loading...</marquee>
  </div>
  <div id="investmentTicker">
    <marquee id="investmentNewsText" scrollamount="6">Investment News: Loading...</marquee>
  </div>
  <div id="netWorthTicker">
    <marquee id="netWorthText" scrollamount="6">Net Worth Changes: Loading...</marquee>
  </div>
  
  <div class="container">
    <!-- Authentication Panel -->
    <div id="auth-panel" class="section">
      <h2>Login / Register</h2>
      <input type="email" id="email" placeholder="Email"><br>
      <input type="password" id="password" placeholder="Password"><br>
      <input type="text" id="username" placeholder="Username (optional)"><br>
      <button onclick="app.login()">Login / Register</button>
      <div id="loginDebug" style="color:yellow; font-size:10px;"></div>
    </div>
    
    <!-- User Panel -->
    <div id="user-panel" class="section" style="display:none;">
      <div style="text-align:right;">
        <button onclick="app.toggleNotifications()">‚úâÔ∏è</button>
        <button onclick="app.logout()">Logout</button>
      </div>
      <h2>Welcome, <span id="displayName"></span></h2>
      
      <!-- Admin Panel (for Holdings Vault Guild management, etc.) -->
      <div id="adminPanel" style="display:none; margin-bottom:10px;">
        <button onclick="app.createGuild()">Create Guild</button>
        <!-- When a guild is created, the guild management panel will replace this section -->
      </div>
      
      <!-- User Info -->
      <div id="userInfo" class="section">
        <p>Vault Type: <span id="vaultTypeDisplay"></span> <span id="upgradeOptions"></span></p>
        <p>Cash: $<span id="cashDisplay"></span></p>
        <div id="vaultClockDisplay">Vault Clock: Loading...</div>
      </div>
      
      <!-- Theme & Customization -->
      <div id="themeBannerSection" class="section">
        <h3>Customize Your Vault</h3>
        <p>Owned Themes: <span id="ownedThemes">None</span></p>
        <p>Select a Theme to Purchase:</p>
        <select id="vaultTheme">
          <option value="default">Gray Default</option>
          <option value="red">Red</option>
          <option value="blue">Blue</option>
          <option value="green">Green</option>
        </select>
        <button onclick="app.purchaseTheme()">Purchase Theme</button>
        <p>Select a Theme from Inventory to Equip:</p>
        <select id="equipThemeSelect"></select>
        <button onclick="app.equipTheme()">Equip Theme</button>
      </div>
      
      <!-- Minting Section -->
      <div id="mintingSection" class="section">
        <h3>Mint a Coin</h3>
        <button id="mintBtn" onclick="app.mintNewCoin()" disabled>Mint New Coin</button>
        <div id="mintedCoinDisplay"></div>
        <p id="mintNotice" style="color:red; font-size:10px;">Minting disabled until market conditions are met.</p>
      </div>
      
      <!-- Static Coin Value Banner (updated every second) -->
      <div id="staticValueTicker">Coin Values: Loading...</div>
      
      <!-- Vault Inventory -->
      <div id="vaultSection" class="section">
        <h3>My Vault</h3>
        <div id="vaultCoins"></div>
        <!-- For Holdings Vaults: Investment Box -->
        <div id="investmentBoxSection" style="display:none;">
          <h4>Investment Box</h4>
          <div id="investmentBoxContent">No investments.</div>
        </div>
      </div>
      
      <!-- Market Interface -->
      <div id="marketInterface" class="section">
        <h3>Market</h3>
        <button onclick="app.toggleMarket()">Toggle Market Interface</button>
        <div id="marketDropdown" style="display:none;">
          <p>List coins from your vault for sale:</p>
          <div id="userCoinsForSale"></div>
          <p>Market Filters:</p>
          <select id="marketFilter" onchange="app.updateMarketListings()">
            <option value="All">All Listings</option>
            <option value="Theme">Themes</option>
            <option value="Copper">Copper</option>
            <option value="Silver">Silver</option>
            <option value="Gold">Gold</option>
            <option value="Platinum">Platinum</option>
            <option value="Diamond">Diamond</option>
            <option value="Iridium">Iridium</option>
            <option value="Rhodium">Rhodium</option>
          </select>
        </div>
        <div id="marketListings" style="background:white; color:black; padding:10px; margin-top:10px;">
          <p>Loading market listings...</p>
        </div>
      </div>
      
      <!-- Theme Sale Section -->
      <div id="themeSaleSection" class="section">
        <h3>List Theme for Sale</h3>
        <p>Select a theme from your inventory to list for sale:</p>
        <select id="listThemeSelect"></select>
        <button onclick="app.listThemeForSale()">List Theme for Sale</button>
      </div>
      
      <!-- Investment Section (only for sending investments; only Holdings can receive) -->
      <div id="investmentSection" class="section">
        <h3>Invest in a Holdings Vault</h3>
        <p>(Only Holdings Vaults can receive investments.)</p>
        <input type="text" id="investRecipient" placeholder="Recipient Username"><br>
        <input type="number" id="investAmount" placeholder="Amount ($)" min="1"><br>
        <button onclick="app.submitInvestment()">Invest</button>
      </div>
      
      <!-- Conversion Section (for Holdings Vaults only) -->
      <div id="conversionSection" class="section">
        <h3>Convert Coins to Cash</h3>
        <!-- "Convert All" button removed -->
        <p>Holdings Conversion - Select Coins to Convert:</p>
        <select id="convertRarity">
          <option value="Copper">Copper</option>
          <option value="Silver">Silver</option>
          <option value="Gold">Gold</option>
          <option value="Platinum">Platinum</option>
          <option value="Diamond">Diamond</option>
          <option value="Iridium">Iridium</option>
          <option value="Rhodium">Rhodium</option>
        </select>
        <input type="number" id="convertQuantity" min="1" placeholder="Quantity">
        <button onclick="app.convertSelectedCoinsToCash()">Convert Selected Coins</button>
        <p id="conversionNotice" style="color:orange; font-size:10px;"></p>
      </div>
      
      <!-- Groups / Guilds Section -->
      <div id="groupSection" class="section">
        <h3>Guilds & Associations</h3>
        <div id="guildControls" class="groupDropdown">
          <h4>Guild (Holdings Vaults)</h4>
          <button onclick="app.createGuild()">Create Guild</button>
          <!-- If a guild is created, display guild management options here -->
        </div>
        <div id="associationControls" class="groupDropdown">
          <h4>Association (Basic Vaults)</h4>
          <button onclick="app.createAssociation()">Create Association</button>
          <button onclick="app.leaveAssociation()">Leave Association</button>
          <button onclick="app.inviteToAssociation()">Invite to Association</button>
          <button onclick="app.toggleGroupSearch()">Search & Join Groups</button>
          <div id="associationInvites"></div>
          <div id="associationInfo"><p>Association Info: None</p></div>
        </div>
      </div>
      
      <!-- Group Search & Leaderboards -->
      <div id="groupSearch" class="groupDropdown" style="display:none;">
        <h4>Search Groups</h4>
        <select id="groupTypeSearch">
          <option value="guilds">Guilds</option>
          <option value="associations">Associations</option>
        </select>
        <input type="text" id="searchQuery" placeholder="Enter group name...">
        <button onclick="app.searchGroups()">Search</button>
        <div id="groupSearchResults"></div>
      </div>
      <div id="topGuildsLeaderboard">
        <h4>Top Guilds Leaderboard</h4>
        <div id="guildLeaderboardContent">Loading...</div>
      </div>
      <div id="topAssociationsLeaderboard">
        <h4>Top Associations Leaderboard</h4>
        <div id="associationLeaderboardContent">Loading...</div>
      </div>
      <div id="leaderboardSection" class="section">
        <h3>Leaderboards</h3>
        <select id="leaderboardFilter" onchange="app.updateLeaderboard()">
          <option value="All">Global</option>
          <option value="Basic">Basic Vaults</option>
          <option value="Investment">Investment Vaults</option>
          <option value="Holdings">Holdings Vaults</option>
        </select>
        <marquee id="leaderboardContent" scrollamount="4">Loading leaderboard...</marquee>
      </div>
    </div>
  </div>
  
  <footer>
    <p>&copy; 2025 Vault Street</p>
  </footer>
  
  <!-- Audio Elements -->
  <audio id="bgMusic" loop>
    <source src="bg-music.mp3" type="audio/mpeg">
  </audio>
  <audio id="sfxMint">
    <source src="sfx-mint.mp3" type="audio/mpeg">
  </audio>
  
  <!-- Consolidated and Modularized Script -->
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      // Firebase initialization
      const firebaseConfig = {
        apiKey: "AIzaSyDfZZUf2pY9ueCx6Q7m86dnitU_voims-8",
        authDomain: "coin-flip-4a693.firebaseapp.com",
        databaseURL: "https://coin-flip-4a693-default-rtdb.firebaseio.com",
        projectId: "coin-flip-4a693",
        storageBucket: "coin-flip-4a693.appspot.com",
        messagingSenderId: "572907715515",
        appId: "1:572907715515:web:68a53fc5a8e4b5157fe29e"
      };
      firebase.initializeApp(firebaseConfig);
      const auth = firebase.auth();
      const db = firebase.database();
      
      // Main app object
      const app = {
        currentUsername: "",
        defaultVaultType: "Basic",
        currentCash: 1000,
        currentVaultType: "",
        canMint: false,
        marketPrices: {},
        recordHighs: {},
        recordLows: { Copper: Infinity, Silver: Infinity, Gold: Infinity, Platinum: Infinity, Diamond: Infinity, Iridium: Infinity, Rhodium: Infinity },
        basePrices: { Copper: 1, Silver: 5, Gold: 10, Platinum: 25, Diamond: 50, Iridium: 75, Rhodium: 100 },
        baselineDropRates: { Copper: 40, Silver: 25, Gold: 15, Platinum: 10, Diamond: 5, Iridium: 3, Rhodium: 1 },
        cycleLength: 300,
        clockStartTime: Date.now(),
        vaultCycleCounter: 0,
        groupedListings: {},
        
        // === Utility Functions ===
        getRatioColor: ratio => ratio < 1.0 ? "red" : ratio > 1.0 ? "green" : "yellow",
        getRarity: () => {
          const roll = Math.random() * 100;
          if (roll < 50) return "Copper";
          else if (roll < 75) return "Silver";
          else if (roll < 87) return "Gold";
          else if (roll < 94) return "Platinum";
          else if (roll < 97) return "Diamond";
          else if (roll < 99) return "Iridium";
          else return "Rhodium";
        },
        calculateVaultScore: coins => {
          if (!coins) return 0;
          const rarityValues = { Copper: 1, Silver: 2, Gold: 3, Platinum: 4, Diamond: 5, Iridium: 6, Rhodium: 7 };
          let score = 0;
          const owned = new Set();
          Object.values(coins).forEach(c => {
            if (c && c.rarity) { score += rarityValues[c.rarity] || 0; owned.add(c.rarity); }
          });
          if (owned.size === 7) score += 5;
          return score;
        },
        updateUserCash: () => {
          const user = auth.currentUser;
          if (!user) return;
          db.ref("users/" + user.uid + "/cash").once("value").then(snap => {
            app.currentCash = snap.val() || 0;
            document.getElementById("cashDisplay").textContent = app.currentCash.toFixed(1);
          });
        },
        playSFX: id => {
          const audio = document.getElementById(id);
          if (!localStorage.getItem("vaultAudioMuted") === "true" && audio) {
            audio.pause();
            audio.currentTime = 0;
            audio.play().catch(e => console.warn("Audio error:", e));
          }
        },
        
        // === Vault Clock and Reset ===
        updateVaultClock: () => {
          const elapsed = Math.floor((Date.now() - app.clockStartTime) / 1000);
          const remaining = app.cycleLength - (elapsed % app.cycleLength);
          const minutes = Math.floor(remaining / 60), seconds = remaining % 60;
          document.getElementById("vaultClockDisplay").textContent = `Vault Clock: ${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
          if (elapsed % app.cycleLength === 0) {
            app.vaultCycleCounter++;
            // Process investments at cycle end; update net worth for Holdings
            app.processInvestments();
            app.vaultClockReset();
          }
        },
        vaultClockReset: () => {
          console.log("Vault Clock Reset Triggered");
          app.processMarketListingsReturn();
          app.updateMintedStats();
          // (Additional periodic logic may be added here)
        },
        updateRecentFluctuations: () => {
          // (Updated logic: still used to update market prices‚Äîsee below)
          db.ref("mintRegistry").once("value").then(snap => {
            const regData = snap.val() || {};
            const highs = { Copper: 0, Silver: 0, Gold: 0, Platinum: 0, Diamond: 0, Iridium: 0, Rhodium: 0 };
            const lows = { Copper: Infinity, Silver: Infinity, Gold: Infinity, Platinum: Infinity, Diamond: Infinity, Iridium: Infinity, Rhodium: Infinity };
            Object.values(regData).forEach(coin => {
              if (coin && coin.rarity) {
                const price = app.marketPrices[coin.rarity] || app.basePrices[coin.rarity];
                highs[coin.rarity] = Math.max(highs[coin.rarity], price);
                lows[coin.rarity] = Math.min(lows[coin.rarity], price);
              }
            });
            app.recordHighs = highs;
            app.recordLows = lows;
            // For ticker we show only current value with color based on base price
            let txt = "Coin Values: ";
            for (const r in app.marketPrices) {
              const price = app.marketPrices[r];
              let color = "yellow";
              if (price > app.basePrices[r]) color = "green"; else if (price < app.basePrices[r]) color = "red";
              txt += `<span style="color:white;">${r}:</span> <span style="color:${color};">$${price.toFixed(2)}</span> | `;
            }
            document.getElementById("marketPricesText").innerHTML = txt;
            if (document.getElementById("staticValueTicker"))
              document.getElementById("staticValueTicker").innerHTML = txt;
          });
        },
        
        // === Theme & Customization Functions ===
        purchaseTheme: () => {
          const selectedTheme = document.getElementById("vaultTheme").value;
          db.ref("themes/" + selectedTheme).once("value").then(snap => {
            const themeData = snap.val() || { owners: 0, purchases: 0 };
            const cost = 250 + (themeData.owners * 25) + (themeData.purchases * 5);
            if (!confirm(`Cost for ${selectedTheme} theme is $${cost}. Confirm purchase?`)) return;
            const user = auth.currentUser;
            if (!user) return;
            db.ref("users/" + user.uid).once("value").then(snapUser => {
              const uData = snapUser.val();
              if (uData.cash < cost) { alert("Not enough cash."); return; }
              const newCash = Number((uData.cash - cost).toFixed(1));
              db.ref("users/" + user.uid).update({ cash: newCash });
              db.ref("users/" + user.uid + "/ownedThemes").push(selectedTheme);
              db.ref("themes/" + selectedTheme).transaction(current => {
                current = current || { owners: 0, purchases: 0 };
                current.owners++; current.purchases++;
                return current;
              });
              alert(`${selectedTheme} theme purchased!`);
              app.updateUserCash();
              app.loadOwnedThemes();
              app.updateEquipThemeSelect();
            });
          });
        },
        loadOwnedThemes: () => {
          const user = auth.currentUser;
          if (!user) return;
          db.ref("users/" + user.uid + "/ownedThemes").once("value").then(snap => {
            const themes = snap.val() || {};
            let html = "";
            for (const key in themes) { html += `<span>${themes[key]}</span> `; }
            document.getElementById("ownedThemes").innerHTML = html || "None";
          });
        },
        updateEquipThemeSelect: () => {
          const user = auth.currentUser;
          if (!user) return;
          db.ref("users/" + user.uid + "/ownedThemes").once("value").then(snap => {
            const themes = snap.val() || {};
            let options = `<option value="">--Select Theme to Equip--</option>`;
            for (const key in themes) { options += `<option value="${themes[key]}">${themes[key]}</option>`; }
            document.getElementById("equipThemeSelect").innerHTML = options;
          });
        },
        equipTheme: () => {
          const selectedTheme = document.getElementById("equipThemeSelect").value;
          if (!selectedTheme) { alert("Select a theme to equip."); return; }
          const user = auth.currentUser;
          if (!user) return;
          db.ref("users/" + user.uid + "/ownedThemes").orderByValue().equalTo(selectedTheme)
            .once("value").then(snap => {
              if (!snap.exists()) { alert("Theme not in inventory."); return; }
              snap.forEach(child => { db.ref("users/" + user.uid + "/ownedThemes/" + child.key).remove(); });
              app.updateVaultTheme(selectedTheme);
              app.updateEquipThemeSelect();
              alert(`${selectedTheme} theme equipped.`);
            });
        },
        updateVaultTheme: theme => {
          const panel = document.getElementById("user-panel");
          panel.style.backgroundColor = (theme === "red") ? "#330000" : (theme === "blue") ? "#000033" : (theme === "green") ? "#003300" : "#1a1a1a";
          if (auth.currentUser) db.ref("users/" + auth.currentUser.uid).update({ theme });
        },
        
        // === Upgrade Functions ===
        displayUpgradeOptions: () => {
          const user = auth.currentUser;
          if (!user) return;
          db.ref("users/" + user.uid).once("value").then(snap => {
            const data = snap.val();
            let upgradeHTML = "";
            if (data.vaultType === "Basic" && data.cash >= 5000)
              upgradeHTML += `<button onclick="app.upgradeVault('Investment',5000)">Upgrade to Investment ($5000)</button>`;
            if (data.vaultType === "Investment" && data.cash >= 10000)
              upgradeHTML += `<button onclick="app.upgradeVault('Holdings',10000)">Upgrade to Holdings ($10000)</button>`;
            document.getElementById("upgradeOptions").innerHTML = upgradeHTML || "";
          });
        },
        upgradeVault: (newType, cost) => {
          const user = auth.currentUser;
          if (!user) return;
          db.ref("users/" + user.uid).once("value").then(snap => {
            const data = snap.val();
            if (data.cash < cost) { alert("Not enough cash."); return; }
            db.ref("users/" + user.uid).update({ vaultType: newType, cash: Number((data.cash - cost).toFixed(1)) });
            document.getElementById("vaultTypeDisplay").textContent = newType;
            app.currentVaultType = newType;
            app.updateUserCash();
            app.displayUpgradeOptions();
            alert("Vault upgraded to " + newType + ".");
          });
        },
        
        // === Investment Functions ===
        // Only Holdings Vaults can receive investments.
        // Investments are stored in an investmentBox in the user's data.
        submitInvestment: () => {
          const investor = auth.currentUser;
          if (!investor) return;
          const recipientName = document.getElementById("investRecipient").value.trim();
          const amount = parseFloat(document.getElementById("investAmount").value);
          if (!recipientName || isNaN(amount) || amount <= 0) { alert("Enter a valid recipient and amount."); return; }
          db.ref("users/" + investor.uid).once("value").then(snap => {
            const invData = snap.val();
            if (invData.cash < amount) { alert("Insufficient cash."); return; }
            db.ref("users").orderByChild("username").equalTo(recipientName)
              .once("value").then(snap2 => {
                if (!snap2.exists()) { alert("Recipient not found."); return; }
                let recipientUid = "", recipientData = {};
                snap2.forEach(childSnap => { recipientUid = childSnap.key; recipientData = childSnap.val(); });
                if (recipientData.vaultType !== "Holdings") { alert("Investments can only be sent to Holdings Vaults."); return; }
                // Deduct investment from investor
                const newInvestorCash = invData.cash - amount;
                db.ref("users/" + investor.uid).update({ cash: newInvestorCash });
                // Add investment to recipient's investmentBox (initialize if not exists)
                db.ref("users/" + recipientUid + "/investmentBox").once("value").then(snapBox => {
                  let currentInvestments = snapBox.val() || [];
                  // Record investment as an object with principal and start net worth.
                  // Record initial netWorth of recipient vault.
                  const initialNetWorth = (recipientData.cash || 0) + app.calculateVaultScore(recipientData.coins) * (app.basePrices.Copper); // simplified calculation
                  currentInvestments.push({ principal: amount, startNetWorth: initialNetWorth, timestamp: Date.now(), investor: app.currentUsername });
                  db.ref("users/" + recipientUid + "/investmentBox").set(currentInvestments);
                });
                alert("Invested $" + amount + " in " + recipientName + ".");
                app.updateUserCash();
              });
          });
        },
        // Process investments at the end of the clock cycle.
        processInvestments: () => {
          // For each Holdings Vault, check their investmentBox,
          // calculate current net worth, and determine returns.
          db.ref("users").once("value").then(snapshot => {
            snapshot.forEach(userSnap => {
              const userData = userSnap.val();
              // Only process for Holdings Vaults that have an investmentBox
              if (userData.vaultType === "Holdings" && userData.investmentBox) {
                const investments = userData.investmentBox;
                // Calculate current net worth = cash + coin value (assume coin value is sum using marketPrices)
                let coinValue = 0;
                if (userData.coins) {
                  Object.values(userData.coins).forEach(coin => {
                    if (coin && coin.rarity)
                      coinValue += app.marketPrices[coin.rarity] || app.basePrices[coin.rarity];
                  });
                }
                const currentNetWorth = (userData.cash || 0) + coinValue;
                // Process each investment:
                investments.forEach(inv => {
                  const netChangePercent = (currentNetWorth - inv.startNetWorth) / inv.startNetWorth;
                  // Example: investor gets principal + bonus (90% of netChange), and recipient gets 10% bonus.
                  const bonusForInvestor = inv.principal * 0.9 * netChangePercent;
                  const bonusForRecipient = inv.principal * 0.1 * netChangePercent;
                  // Send bonus to investor (this would normally credit the investor's account)
                  // For demonstration, we simply alert this information.
                  alert(`Investment Return: Investor ${inv.investor} receives $${(inv.principal + bonusForInvestor).toFixed(2)} (with recipient bonus $${bonusForRecipient.toFixed(2)}).`);
                  // Remove the investment after processing. (In production, update the database to remove these records.)
                });
                // Clear the investmentBox after processing
                db.ref("users/" + userSnap.key + "/investmentBox").remove();
                // Optionally update a UI element to display investment cash.
              }
            });
          });
        },
        
        // === Admin Functions ===
        adminResetMarket: () => {
          const user = auth.currentUser;
          if (user && user.email === "stewmin20k@gmail.com" && app.currentUsername === "stewmin") {
            db.ref("tradeStats").update({ averageTradeRatio: 1.0 });
            alert("Market reset by admin.");
            app.updateMintAccess();
          } else { alert("Admin access required."); }
        },
        adminClearCoinHistory: () => {
          const user = auth.currentUser;
          if (user && user.email === "stewmin20k@gmail.com" && app.currentUsername === "stewmin") {
            if (confirm("Clear all coin history? This action cannot be undone.")) {
              db.ref("mintRegistry").remove();
              db.ref("marketListings").remove();
              db.ref("users").once("value").then(snapshot => {
                snapshot.forEach(userSnap => { db.ref("users/" + userSnap.key + "/coins").remove(); });
              });
              alert("Coin history cleared.");
              app.updateMintedStats();
              app.loadVault();
              app.updateMarketListings();
            }
          } else { alert("Admin access required."); }
        },
        adminSwitchVaultType: () => {
          const user = auth.currentUser;
          if (!user || user.email !== "stewmin20k@gmail.com") { alert("Admin access required."); return; }
          const newType = prompt("Enter new vault type (Basic, Investment, Holdings):");
          if (!newType || !["Basic", "Investment", "Holdings"].includes(newType)) { alert("Invalid vault type."); return; }
          db.ref("users/" + user.uid).update({ vaultType: newType });
          document.getElementById("vaultTypeDisplay").textContent = newType;
          alert("Vault type switched to " + newType);
        },
        
        // === Authentication ===
        login: () => {
          const email = document.getElementById("email").value.trim();
          const pass = document.getElementById("password").value.trim();
          const usernameInput = document.getElementById("username").value.trim();
          document.getElementById("loginDebug").innerText = "";
          console.log("Attempting login for: " + email);
          auth.signInWithEmailAndPassword(email, pass)
            .then(cred => { console.log("Logged in as:", cred.user.email); })
            .catch(error => {
              console.log("Login error:", error.message);
              auth.createUserWithEmailAndPassword(email, pass)
                .then(cred => {
                  app.currentUsername = usernameInput || email.split("@")[0];
                  console.log("Account created for:", cred.user.email);
                  db.ref("users/" + cred.user.uid).set({
                    email: cred.user.email,
                    username: app.currentUsername,
                    vaultType: app.defaultVaultType,
                    cash: app.currentCash,
                    theme: "default",
                    coins: {},
                    investmentsReceived: {},
                    investmentsSent: {},
                    lastConversion: 0,
                    guild: null,
                    association: null,
                    ownedThemes: {},
                    investmentBox: []  // Initialize investment box for Holdings Vaults
                  });
                })
                .catch(err => {
                  document.getElementById("loginDebug").innerText = err.message;
                  console.error("Creation error:", err);
                  alert(err.message);
                });
            });
        },
        logout: () => { auth.signOut(); }
      };
      
      // Firebase Auth Listener
      auth.onAuthStateChanged(user => {
        if (user) {
          document.getElementById("auth-panel").style.display = "none";
          document.getElementById("user-panel").style.display = "block";
          db.ref("users/" + user.uid).once("value").then(snap => {
            const data = snap.val() || {};
            if (!data.vaultType) { data.vaultType = app.defaultVaultType; db.ref("users/" + user.uid).update({ vaultType: app.defaultVaultType }); }
            if (!data.cash) { data.cash = app.currentCash; db.ref("users/" + user.uid).update({ cash: app.currentCash }); }
            if (!data.theme) { data.theme = "default"; db.ref("users/" + user.uid).update({ theme: "default" }); }
            document.getElementById("vaultTypeDisplay").textContent = data.vaultType;
            app.currentVaultType = data.vaultType;
            app.currentCash = data.cash;
            document.getElementById("cashDisplay").textContent = Number(app.currentCash).toFixed(1);
            app.currentUsername = data.username || "";
            if (!app.currentUsername) {
              app.currentUsername = document.getElementById("username").value.trim() || user.email.split("@")[0];
              db.ref("users/" + user.uid).update({ username: app.currentUsername });
            }
            document.getElementById("displayName").innerText = app.currentUsername;
            if (user.email === "stewmin20k@gmail.com") {
              app.currentUsername = "stewmin";
              db.ref("users/" + user.uid).update({ username: "stewmin" });
              document.getElementById("adminPanel").style.display = "block";
            } else { document.getElementById("adminPanel").style.display = "none"; }
            // If vault is Holdings, show the investment box section
            if(app.currentVaultType === "Holdings"){
              document.getElementById("investmentBoxSection").style.display = "block";
            } else {
              document.getElementById("investmentBoxSection").style.display = "none";
            }
            app.updateMintAccess();
            app.loadVault();
            app.loadUserCoinsForSale();
            app.updateMarketListings();
            app.updateLeaderboard();
            app.loadOwnedThemes();
            app.updateEquipThemeSelect();
            app.displayUpgradeOptions();
          });
        } else {
          document.getElementById("auth-panel").style.display = "block";
          document.getElementById("user-panel").style.display = "none";
        }
      });
      
      // Audio Setup
      let muted = localStorage.getItem("vaultAudioMuted") === "true";
      document.getElementById("bgMusic").muted = muted;
      window.toggleAudio = () => { muted = !muted; localStorage.setItem("vaultAudioMuted", muted); document.getElementById("bgMusic").muted = muted; };
      
      // Start intervals
      setInterval(app.updateVaultClock, 1000);  // update clock every second
      setInterval(app.updateMarketPrices, 60000);
      setInterval(app.updateMarketListings, 30000);
      setInterval(app.updateLeaderboard, 60000);
      // Update ticker banner (marketPrices and static ticker) every second
      setInterval(app.updateRecentFluctuations, 1000);
      setInterval(app.processMarketListingsReturn, app.cycleLength * 1000);
      
      // Initial calls
      app.updateVaultClock();
      app.updateMarketPrices();
      
      window.app = app;
    });
  </script>
</body>
</html>
